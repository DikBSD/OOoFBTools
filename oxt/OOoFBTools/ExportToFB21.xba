<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE script:module PUBLIC "-//OpenOffice.org//DTD OfficeDocument 1.0//EN" "module.dtd">
<script:module xmlns:script="http://openoffice.org/2000/script" script:name="ExportToFB21" script:language="StarBasic">REM  *****  BASIC  *****
Option Explicit

Public sCurDocFile As String
Public oTextOutputStream As Object
Public sBookAnnotation() As String &apos; массив хранит &quot;обработанную&quot; Аннотацию на Книгу
Public sBodyParagraphs() As String &apos; массив хранит &quot;обработанные&quot; абзацы Книги
Public sLinksTo() As String	&apos; массив ссылок КУДА и их ID
Public sConvertorName As String &apos; название конвертора

&apos; для аннотации
Public bMergeAnnotationSubTitle As Boolean
&apos; оформление подзаголовков
Public bMergeSubTitle As Boolean
&apos; оформление авторов эпиграфов
Public bMergeEpigraphAuthors As Boolean
&apos; оформление заголовков стихов
Public bMergePoemTitle As Boolean
&apos; оформление авторов стихов
Public bMergePoemAuthors As Boolean
&apos; оформление подзаголовков поэм
Public bMergePoemSubTitle As Boolean
&apos; оформление авторов цитат
Public bMergeCiteAuthors As Boolean
&apos; оформление подзаголовков цитат
Public bMergeCiteSubTitle As Boolean
&apos; удаление пустых строк
Public bDelEL As Boolean
&apos; обработка &quot;проблемных&quot; знаков (&lt; &gt;)
Public bCorrectPara As Boolean
&apos; обработка ссылок внутри документа
Public bDocLinks As Boolean
Public bSaveImageTitle As Boolean &apos; сохранение названия картинки, как аттрибута &quot;title&apos;
Public bExportGraphics As Boolean &apos; экспорт Графики
Public sGifAs As String &apos; формат преоьбразования для gif
Public sTifBMPAs As String &apos; формат преоьбразования для tif, tiff, bmp
Public sAnyAs As String &apos; формат преоьбразования для остальных форматов
Public sOLEAs As String &apos; формат преоьбразования для формул и диаграмм
&apos; &quot;Служебная область&quot; для &quot;служебных стилей&quot; (по умолчанию - верх документа)
Public bUp As Boolean
&apos; экспорт форматирования стилями слов
Public bOnlyOneStyle As Boolean
&apos; сохранение fb2-файла в utf-8, если в тексте есть маркерные строки
Public bSaveUTF8 As Boolean

&apos; Чистка fb2 кода
Public bSuperfluous As Boolean &apos; Убираем пустышки типа &lt;/x&gt;&lt;x&gt;
Public bStyleSpace As Boolean  &apos; Обработка пробелов, обрамленными стилями &lt;/x&gt; &lt;x&gt; и &lt;x&gt; &lt;/x&gt;
&apos; запустить сгенерированный fb2-файл на просмотр
Public bFB2Execute As Boolean
&apos; валидация
Public bValidate As Boolean

Private lCurrentElement As Long &apos; номер текущего элемента структуры - для создания текста документа

Sub ExportToFB21()
	sConvertorName = &quot;ExportToFB2.1&quot;
	
	&apos; АЛГОРИТМ - Очень ВАЖНО!!!
	&apos; т.к. конвертор развивается, и в диалоге Переопределения пользовательских стилей появляются НОВЫЕ поля стилей,
	&apos; а у пользователей УЖЕ СОХРАНЕН файл styles.txt, где данных для этих новых стилей нет,
	&apos; то при работе конвертора может произойти либо ошибка, либо экспорт выделенных новыми стилями абзацев
	&apos; будет сделан, как просто абзацы (&lt;p&gt;......&lt;/p&gt;), что не верно.
	&apos; Поэтому, сначала устанавливаем значения переменных по умолчанию (SetStylesVarsDefault),
	&apos; а потом - считываем из файла значения стилей в переменные (ReadStylesInVars).
	&apos; Для тех новых полей, которых еще нет в файле styles.txt значения будут по умолчанию, а для остальных - считаны из файла.
	&apos; Когда же User запустит форму и пересохранит ВСЕ стили, то вне переменные и контролы будут иметь значения из файла!
	
	&apos; Установка стилей по умолчанию
	SetStylesVarsDefault()
	&apos; Только теперь загружаем стили из файла в переменные
	ReadStyles( getUserPath() &amp; sConstStyles, False )

	Dim oFileAccess As Object
	oFileAccess = CreateUnoService(&quot;com.sun.star.ucb.SimpleFileAccess&quot;)
	oTextOutputStream = CreateUnoService(&quot;com.sun.star.io.TextOutputStream&quot;)
	Dim oDoc As Object : oDoc = ThisComponent

	&apos; инициализация сообщений основной формы конвертера в зависимости от локали
	InitInfoDlgMessage()
	
	If oDoc.hasLocation() Then
		sCurDocFile = oDoc.getURL
	Else
		MsgBox sIDD.sFB2ExportSaveMessage, 64, sConvertorName
		Exit Sub
	End If
	
	If oDoc.isModified() Then
		If MsgBox ( sIDD.sFB2ExportSaveModified, 32 + 1 + 256, sConvertorName ) = 2 Then
			Exit Sub
		End If
	End If
	
	&apos; меняем расширение на fb2
	Dim sFile() As String, i As Integer
	sFile = Split(sCurDocFile, &quot;.&quot;)
	If UBound(sFile) &gt; 0 Then
		For i=0 To UBound(sFile)
			sFile(UBound(sFile)) = &quot;fb2&quot;
		Next i
		sCurDocFile = Join(sFile, &quot;.&quot;)
	Else &apos; файл без точки расширения
		sCurDocFile = sCurDocFile &amp; &quot;.fb2&quot;
	End If
	
	If Not InfoDlgExec() Then
		Exit Sub
	End If
	
	&apos; если есть картинки (ДО абзаца со стилем Названия Книги), то сначала формируем тэги обложек
	If IsStyleExists( sStyleBookTitle ) And ( ThisComponent.getGraphicObjects().Count &gt; 0 Or ThisComponent.getDrawPage().Count &gt; 0) Then
		MakeCoverParser()
	End If

	oProgressBar.start( sIDD.sFB2ExportProgressBarAnalysis, oDoc.ParagraphCount + 50 )
	oProgressBar.setValue( 0 )
	
	&apos; запускаем парсинг всего текста
	DocumentParser()
	
	&apos; Создание fb2 файла
	Dim oOutputStream As Object
	oOutputStream = oFileAccess.openFileWrite( ConvertToUrl( oInfoDlg.Model.FilenameTextField.Text ) )
	oOutputStream.truncate()
	oTextOutputStream.setOutputStream( oOutputStream )

	Dim oCodeLB As Object : oCodeLB = oInfoDlg.getControl( &quot;Codepage&quot; )
	Dim sFB2Encoding As String : sFB2Encoding = oCodeLB.SelectedItem
	oTextOutputStream.setEncoding( oCodeLB.SelectedItem )
	If bSaveUTF8 And bMarker Then 	&apos; сохранение fb2-файла в UTF-8, т.к. в тексте есть маркерные списки
		sFB2Encoding = &quot;utf-8&quot;
	End If
	oTextOutputStream.setEncoding( sFB2Encoding )
	
	&apos; печатаем данные из &lt;description&gt;
	SaveDescription( sFB2Encoding, False )
	
	&apos; печатаем данные из &lt;body&gt;
	oTextOutputStream.writeString(&quot;&lt;body&gt;&quot; &amp; chr(10))
	SaveBody()
	oTextOutputStream.writeString(&quot;&lt;/body&gt;&quot; &amp; chr(10))
	
	If UBound(sFootnoteText()) &lt;&gt; -1 Then
		oProgressBar.start( sIDD.sFB2ExportProgressBarFootnote, UBound(sFootnoteText() )
		oProgressBar.setValue(0)
		SaveNotes()
	End If
	
	&apos; печатаем коды картинок, если они есть
	Dim iSI As Integer
	If UBound(Images()) &lt;&gt; -1 Then
		oProgressBar.start( sIDD.sFB2ExportProgressBarGraphics, UBound(Images() )
		oProgressBar.setValue(0)
		iSI = SaveImages()
	End If
	
	oTextOutputStream.writeString(&quot;&lt;/FictionBook&gt;&quot; &amp; chr(10))
	oTextOutputStream.closeOutput()
	oProgressBar.End
		
	&apos; запустить полученный файл на просмотр и валидацию, если нужно
	Dim sEndMessage	As String : sEndMessage	= sIDD.sFB2ExportEnd
	If iSI &gt; 0 Then
		sEndMessage = sEndMessage &amp; chr(10) &amp; sIDD.sFB2ExportReport &amp; &quot; &quot; &amp; iSI &amp; &quot; &quot; &amp; sIDD.sFB2ExportReportFrom &amp; _
		&quot; &quot; &amp; UBound(Images())+1 &amp; &quot; &quot; &amp; sIDD.sFB2ExportReportFromSearcing
	End If
	
	Dim sFB2File As String : sFB2File = oInfoDlg.Model.FilenameTextField.Text
	Dim sMess As String : sMess = sEndMessage &amp; chr(10) &amp; chr(10)
	
	If bValidate And GetOS() = 0 Then
		sMess = sMess &amp; sIDD.sFB2ExportStartValidate &amp; chr(10) &amp; chr(10)
		Validate( sFB2File ) &apos;валидация результата
	End If

	If bFB2Execute Then
		FileExecute( ConvertToUrl( sFB2File ) )
		MsgBox sMess &amp; sIDD.sFB2ExportReportGeneratedFB2File &amp; chr(10) &amp; _
				sFB2File &amp; chr(10) &amp; sIDD.sFB2ExportReportStartToPreview, 64, sConvertorName
	Else
		MsgBox sMess &amp; sIDD.sFB2ExportReportFile &amp; &quot; &quot; &amp; sFB2File, 64, sConvertorName
	End If
	
	&apos; удаляем временные файлы
	If Dir( getOOoFBToolsTempPath(), 16 ) &lt;&gt; &quot;&quot; Then
		RmDir getOOoFBToolsTempPath()
	End If
	
	oInfoDlg.Dispose()
End Sub

Function SaveCloseSection(nCount As Integer) As Long
	Dim i As Integer
	If nCount &gt; 0 Then
		For i = 0 To nCount-1
			oTextOutputStream.writeString(&quot;&lt;/section&gt;&quot; &amp; chr(10))
		Next i
	End If
End Function

Function IsLevel(sStyle As String) As Boolean
	&apos; Если аргумент sStyle - это Уровень, то возвращается True, иначе - False
	Select Case sStyle
			Case sStyleLevel1
				IsLevel = True
			Case sStyleLevel2
				IsLevel = True
			Case sStyleLevel3
				IsLevel = True
			Case sStyleLevel4
				IsLevel = True
			Case sStyleLevel5
				IsLevel = True
			Case sStyleLevel6
				IsLevel = True
			Case sStyleLevel7
				IsLevel = True
			Case sStyleLevel8
				IsLevel = True
			Case sStyleLevel9
				IsLevel = True
			Case sStyleLevel10
				IsLevel = True
			Case Else &apos; это не Уровень
				IsLevel = False
		End Select
End Function

Function IndexOf1Section(sArray As String) As Long
	&apos; индекс 1-й секции
	Dim i As Long
	For i = 0 To UBound(sArray)
		If IsLevel(sArray(i,1)) = True Then
			IndexOf1Section = i
			Exit For
		Else
			IndexOf1Section = -1
		End If
	Next i
End Function

Function IndexOfEndSection(sArray As String) As Long
	&apos; индекс последней секции
	Dim i As Long
	For i = UBound(sArray) To 0 Step -1 
		If  IsLevel(sArray(i,1)) = True Then
			IndexOfEndSection = i
			Exit For
		Else
			IndexOfEndSection = -1
		End If
	Next i
End Function

Function GetCountSection(sArray As String, lIndexOfCurrentLevel As Long, lIndexOfNextLevel As Long, lIndexOfEndSection As Long) As Integer
	&apos; сравнение по индексам, расчет по номерам уровней
	If lIndexOfCurrentLevel &lt; lIndexOfEndSection Then 
		GetCountSection = ( GetLevelNumber(sArray(lIndexOfCurrentLevel,1)) - _
							GetLevelNumber(sArray(lIndexOfNextLevel,1)) ) + 1
	Else
		GetCountSection = GetLevelNumber(sArray(lIndexOfEndSection,1))
	End If
End Function

Function GetIndexOfNextLevel(sArray As String, lIndexOfCurrentLevel As Long) As Long
	Dim i As Long, sInput As String
	&apos; Ищем следующий индекс уровня после LevelCurrent
	If lIndexOfCurrentLevel = UBound(sArray) Then
		GetIndexOfNextLevel = lIndexOfCurrentLevel
		Exit Function
	End If
	For i = lIndexOfCurrentLevel+1 To UBound(sArray)
		sInput = sArray(i,1)
		If  IsLevel(sInput) = True Then
			GetIndexOfNextLevel = i
			Exit For
		End If
	Next i
End Function

Function GetLevelNumber(Level As String) As Integer
	&apos; Возвращает номер уровня (число) из строки уровня
	Select Case Level
		Case sStyleLevel1
			GetLevelNumber = 1
		Case sStyleLevel2
			GetLevelNumber = 2
		Case sStyleLevel3
			GetLevelNumber = 3
		Case sStyleLevel4
			GetLevelNumber = 4
		Case sStyleLevel5
			GetLevelNumber = 5
		Case sStyleLevel6
			GetLevelNumber = 6
		Case sStyleLevel7
			GetLevelNumber = 7
		Case sStyleLevel8
			GetLevelNumber = 8
		Case sStyleLevel9
			GetLevelNumber = 9
		Case sStyleLevel10
			GetLevelNumber = 10
	End Select
End Function

Function SaveFBCorrectText(sStr As String, bCHR10 As Boolean)
	Dim sR(5) As Integer, sR1(5) As Integer, sR2(5) As Integer
	If bSuperfluous = True Then
		RemoveSuperfluous(sStr, sR)
	End If
	If bStyleSpace = True Then
		ClearStyleSpace(sStr, sR1, sR2)
	End If
	If bCHR10 = True Then
		oTextOutputStream.writeString(sStr &amp; chr(10))
	Else
		oTextOutputStream.writeString(sStr)
	End If
End Function

Function SaveElements(sArray() As String, sParaStyleName As String, sPara As String, bBody As Boolean)
	&apos; перебор по стилям
	Dim sStr As String, bFB2Clear As Boolean
	Select Case sParaStyleName
		Case sStylePoemTitle
			sStr = MakePoem(sArray, bBody)
			SaveFBCorrectText(sStr, True)
		Case sStylePoemSubTitle
			sStr = MakePoem(sArray, bBody)
			SaveFBCorrectText(sStr, True)
		Case sStylePoem
			sStr = MakePoem(sArray, bBody)
			SaveFBCorrectText(sStr, True)
		Case sStyleEpigraph
			sStr = MakeEpigraph(sArray, sStyleEpigraph, sStyleEpigraphAuthor, bBody)
			SaveFBCorrectText(sStr, True)
		Case sStyleCite
			sStr = MakeCite(sArray, bBody)
			SaveFBCorrectText(sStr, True)
		Case sStyleCiteSubTitle
			sStr = MakeCite(sArray, bBody)
			SaveFBCorrectText(sStr, True)
		Case sStyleAnnotation
			sStr = MakeAnnotation(sArray, bBody)
			SaveFBCorrectText(sStr, True)
		Case sStyleAnnotationSubTitle
			sStr = MakeAnnotation(sArray, bBody)
			SaveFBCorrectText(sStr, True)
		Case sStyleSubTitle
			sStr = MakeSubTitle(sArray, sStyleSubTitle, bMergeSubTitle, bBody)
			SaveFBCorrectText(sStr, True)
		Case sStyleLevel1
			sStr = MakeSection(sArray, sParaStyleName, bBody)
			SaveFBCorrectText(sStr, True)
		Case sStyleLevel2
			sStr = MakeSection(sArray, sParaStyleName, bBody)
			SaveFBCorrectText(sStr, True)
		Case sStyleLevel3
			sStr = MakeSection(sArray, sParaStyleName, bBody)
			SaveFBCorrectText(sStr, True)
		Case sStyleLevel4
			sStr = MakeSection(sArray, sParaStyleName, bBody)
			SaveFBCorrectText(sStr, True)
		Case sStyleLevel5
			sStr = MakeSection(sArray, sParaStyleName, bBody)
			SaveFBCorrectText(sStr, True)
		Case sStyleLevel6
			sStr = MakeSection(sArray, sParaStyleName, bBody)
			SaveFBCorrectText(sStr, True)
		Case sStyleLevel7
			sStr = MakeSection(sArray, sParaStyleName, bBody)
			SaveFBCorrectText(sStr, True)
		Case sStyleLevel8
			sStr = MakeSection(sArray, sParaStyleName, bBody)
			SaveFBCorrectText(sStr, True)
		Case sStyleLevel9
			sStr = MakeSection(sArray, sParaStyleName, bBody)
			SaveFBCorrectText(sStr, True)
		Case sStyleLevel10
			sStr = MakeSection(sArray, sParaStyleName, bBody)
			SaveFBCorrectText(sStr, True)
		Case &quot;&quot; &apos; &lt;empty-line/&gt;
			If bDelEL = False Then
				oTextOutputStream.writeString(&quot;&lt;empty-line/&gt;&quot; &amp; chr(10))
			Else
				If lCurrentElement &gt; 0 And lCurrentElement &lt; UBound(sArray) Then
					If IsLevel( sArray(lCurrentElement-1,1) ) And IsLevel( sArray(lCurrentElement+1,1) ) Then
						If sArray(lCurrentElement-1,1) = sArray(lCurrentElement+1,1) Then
							&apos; обработка смежных уровней одного ранга - если между ними только пустая строка, то ее не удаляем - иначе - невалидность fb2-файла.
							oTextOutputStream.writeString(&quot;&lt;empty-line/&gt;&quot; &amp; chr(10))
						Else
							&apos; проверка - следующая строка в массиве - уровень меньшего ранга?
							Dim sLevels(9) As String
							Dim i As Integer, nPrev As Integer, nNext As Integer
							sLevels = Array(sStyleLevel1, sStyleLevel2, sStyleLevel3, sStyleLevel4, sStyleLevel5, _
											sStyleLevel6, sStyleLevel7, sStyleLevel8, sStyleLevel9, sStyleLevel10)
							For i=LBound(sLevels) To UBound(sLevels)
								If sArray(lCurrentElement-1, 1) = sLevels(i) Then
									nPrev = i
								End If
								If sArray(lCurrentElement+1, 1) = sLevels(i) Then
									nNext = i
								End If
							Next i
							If nPrev = nNext+1 Then
								&apos; пустая строка между уровнями с большего на меньший ранг - оставляем
								oTextOutputStream.writeString(&quot;&lt;empty-line/&gt;&quot; &amp; chr(10))
							End If
						End If
					ElseIf sArray(lCurrentElement-1,1) = &quot;Table&quot; And sArray(lCurrentElement+1,1) = &quot;Table&quot; Then
						&apos; не убираем пустую строку между 2-мя таблицами - в читалке сливаются иначе...
						oTextOutputStream.writeString(&quot;&lt;empty-line/&gt;&quot; &amp; chr(10))
					End If
				Else
					If sArray(lCurrentElement, 1) = &quot;&quot; Then
						&apos; Защита от &quot;вылетания&quot; конвертора, на случай, если последний абзац -
						&apos; Уровень (в нарушение схемы), Эпиграф (в нарушение схемы), Поема, Цитата
						oTextOutputStream.writeString(&quot;&lt;empty-line/&gt;&quot; &amp; chr(10))
					End If
				End If
			End If
			lCurrentElement = lCurrentElement+1
		Case &quot;Table&quot; 
			sStr = sPara
			SaveFBCorrectText(sStr, True)
			lCurrentElement = lCurrentElement+1
		Case &quot;Image&quot; 
			oTextOutputStream.writeString(sPara &amp; chr(10))
			lCurrentElement = lCurrentElement+1
		Case &quot;end-fn&quot; &apos; только для сносок - последний &quot;ненужный&quot; элемент массива
			If bBody = False Then &apos; еще раз убедимся, что это - сноска
				If lCurrentElement &lt;= UBound( sArray() ) Then &apos; чтобы &quot;не вылетить&quot; за границу индекса, на всякий случай
					If IsLevel( sArray( lCurrentElement-1, 1 ) ) = True Or _
						sArray( lCurrentElement-1, 1 ) = sStyleAnnotation Or _
						sArray( lCurrentElement-1, 1 ) = sStyleAnnotationSubTitle Or _
						sArray( lCurrentElement-1, 1 ) = sStyleEpigraph Or _
						sArray( lCurrentElement-1, 1 ) = sStyleEpigraphAuthor Then
						&apos; Только для Уровней, Аннотации и Эпиграфа оставляем пустую строку
						oTextOutputStream.writeString(&quot;&lt;empty-line/&gt;&quot; &amp; chr(10))
					End If
				End If
			End If
			lCurrentElement = lCurrentElement+1
		Case Else &apos; что-то другое или просто параграф - записываем как параграф
			If bDocLinks = True Then
				&apos; обработка ссылок внутри документа
				Dim sID As String
				If FindIndexForID(lCurrentElement, sID, bBody) &lt;&gt; -1 Then &apos; нашли закладку (ссылку) для текущего элемента
					sStr = &quot;&lt;p &quot; &amp; &quot;id=&quot;&quot;&quot; &amp; sID &amp; &quot;&quot;&quot;&gt;&quot; &amp; sPara &amp; &quot;&lt;/p&gt;&quot; &amp; chr(10)
				Else &apos; для текущего элемента нет ни одной закладки (и ссылки, соответственно)
					sStr = &quot;&lt;p&gt;&quot; &amp; sPara &amp; &quot;&lt;/p&gt;&quot; &amp; chr(10)
				End If
			Else
				sStr = &quot;&lt;p&gt;&quot; &amp; sPara &amp; &quot;&lt;/p&gt;&quot; &amp; chr(10)
			End If
			SaveFBCorrectText(sStr, False)
			lCurrentElement = lCurrentElement+1
	End Select
End Function

Function MakeBookTitle As String
	&apos; формируем заглавие книги
	If lBATIndex &gt; -1 Then
		lCurrentElement = lBATIndex &apos; если есть автор или название книги, то все, что &quot;выше&quot; - игнорируем - служебная зона
		Dim sBT As String, l As Long, sID As String, sBookTag As String
		sBT = &quot;&lt;title&gt;&quot; &amp; chr(10)
		For l = lCurrentElement To UBound(sBodyParagraphs)
			If sBodyParagraphs(l,1) = sStyleBookTitle Then
				If bDocLinks = True Then
					&apos; обработка ссылок внутри документа
					If FindIndexForID(l, sID, True) &lt;&gt; -1 Then &apos; нашли закладку (ссылку) для текущего элемента
						sBookTag = &quot;&lt;p &quot; &amp; &quot;id=&quot;&quot;&quot; &amp; sID &amp; &quot;&quot;&quot;&gt;&quot;
					Else &apos; для текущего элемента нет ни одной закладки (и ссылки, соответственно)
						sBookTag = &quot;&lt;p&gt;&quot; &apos; нет ни одной закладки
					End If
				Else
					sBookTag = &quot;&lt;p&gt;&quot;
				End If
				sBT = sBT &amp; sBookTag &amp; sBodyParagraphs(l,0) &amp; &quot;&lt;/p&gt;&quot; &amp; chr(10)
				oProgressBar.setValue(l) &apos; Статусбар
			Else Exit For
			End If
		Next l
		lCurrentElement = l
		MakeBookTitle = sBT &amp; &quot;&lt;/title&gt;&quot; &amp; chr(10)
	End If
End Function

Function MakePoemTitle(sArray As String, bBody As Boolean) As String
	Dim l As Long, sID As String, sPTag As String
	Dim sPoemTitle As String
	sPoemTitle = &quot;&quot;
	If bMergePoemTitle = True Then &apos; собираем Заголовки стиха, идущие один за другим в одну строку
		Dim nCount As Integer, nCountTag As String &apos; число заголовков с закладками
		nCount = 0
		nCountTag = 0
		For l = lCurrentElement To UBound(sArray)
			If sArray(l,1) = sStylePoemTitle Then
				If bDocLinks = True Then
					&apos; обработка ссылок внутри документа
					If FindIndexForID(l, sID, bBody) &lt;&gt; -1 Then &apos; нашли закладку (ссылку) для текущего элемента
						sPTag = &quot;&lt;p &quot; &amp; &quot;id=&quot;&quot;&quot; &amp; sID &amp; &quot;&quot;&quot;&gt;&quot;
						nCount = nCount+1 &apos;счетчик закладок
					Else &apos; для текущего элемента нет ни одной закладки (и ссылки, соответственно)
						If nCount = 0 Then &apos; чтобы не &quot;затереть&quot; закладки вышестоящих заголовков
							sPTag = &quot;&lt;p&gt;&quot; &apos; нет ни одной закладки
						End If
					End If
				Else
					sPTag = &quot;&lt;p&gt;&quot;
				End If
				If nCountTag = 0 Then &apos; чтобы не добавлять и другие теги &lt;p id=&gt;
					sPoemTitle = sPoemTitle &amp; sPTag
					nCountTag = nCountTag+1 &apos;счетчик закладок
				End If
				sPoemTitle = sPoemTitle &amp; sArray(l,0) &amp;  &quot; &quot;
				oProgressBar.setValue(l) &apos; Статусбар
			Else Exit For
			End If
		Next l
		sPoemTitle = Mid(sPoemTitle, 1, Len(sPoemTitle)-1)
		sPoemTitle = sPoemTitle &amp; &quot;&lt;/p&gt;&quot;
		lCurrentElement = l
	Else &apos; Заголовки стиха не будут собираться в одну строку, а будут один под другим
		For l = lCurrentElement To UBound(sArray)
			If sArray(l,1) = sStylePoemTitle Then
				If bDocLinks = True Then
					&apos; обработка ссылок внутри документа
					If FindIndexForID(l, sID, bBody) &lt;&gt; -1 Then &apos; нашли закладку (ссылку) для текущего элемента
						sPTag = &quot;&lt;p &quot; &amp; &quot;id=&quot;&quot;&quot; &amp; sID &amp; &quot;&quot;&quot;&gt;&quot;
					Else &apos; для текущего элемента нет ни одной закладки (и ссылки, соответственно)
						sPTag = &quot;&lt;p&gt;&quot; &apos; нет ни одной закладки
					End If
				Else
					sPTag = &quot;&lt;p&gt;&quot;
				End If
				sPoemTitle = sPoemTitle &amp; sPTag &amp; sArray(l,0) &amp; &quot;&lt;/p&gt;&quot; &amp; chr(10)
				oProgressBar.setValue(l) &apos; Статусбар
			Else Exit For
			End If
		Next l
		lCurrentElement = l
	End If
	If sPoemTitle &lt;&gt; &quot;&quot; Then
		MakePoemTitle = &quot;&lt;title&gt;&quot; &amp; sPoemTitle &amp; &quot;&lt;/title&gt;&quot; &amp; chr(10)
	Else
		MakePoemTitle = &quot;&quot;
	End If
End Function

Function MakePoem(sArray As String, bBody As Boolean) As String
	Dim sPoem As String, l As Long, sID As String
	Dim sPoemTitle As String, sPoemEpigraph As String, sSwitch As String
	sPoem = &quot;&quot;
	&apos; Заголовок поэмы
	sPoemTitle = MakePoemTitle(sArray, bBody)
	If sPoemTitle &lt;&gt; &quot;&quot; Then &apos; стихи с заголовка
		sPoem = sPoem &amp; chr(10) &amp; sPoemTitle
	End If
	&apos; Эпиграф Поэмы
	If sArray(lCurrentElement,1) = sStyleEpigraph Then &apos; против зацикливания - из Поэмы в Эпиграф и обратно
		sPoemEpigraph = MakeEpigraph(sArray, sStyleEpigraph, sStyleEpigraphAuthor, bBody)
	End If

	If sPoemEpigraph &lt;&gt; &quot;&quot; Then &apos; стихи с эпиграфом
		sPoem = sPoem &amp; sPoemEpigraph
	End If
	&apos; Переключатель - Stanza или SubTitle Поэмы
	sSwitch = SwitchSubTitleStanza(sArray, bBody)
	If sSwitch &lt;&gt; &quot;&quot; Then
		sPoem = sPoem &amp; sSwitch
	End If
	
	&apos; Заглушка, на случай, если есть Заголовок и (или) Эпиграф поэмы, а обязательного Подзаголовка или Станзы - нет
&apos;	If (sPoemTitle &lt;&gt; &quot;&quot; OR sPoemEpigraph &lt;&gt; &quot;&quot;) AND sSwitch = &quot;&quot; Then
&apos;		sPoem = sPoem &amp; &quot;&lt;stanza&gt;&lt;v&gt;?&lt;/v&gt;&lt;/stanza&gt;&quot; &amp; chr(10)
&apos;	End If
	
	&apos; Авторы поэмы, если они есть
	sPoem = sPoem &amp; MakePoemAuthor(sArray, bBody)
	&apos; Дата написания поэмы, если она есть
	sPoem = sPoem &amp; MakePoemDate(sArray, bBody)

	If sPoem &lt;&gt; &quot;&quot; Then
		MakePoem = &quot;&lt;poem&gt;&quot; &amp; sPoem &amp; &quot;&lt;/poem&gt;&quot;
	Else
		MakePoem = &quot;&quot;
	End If
End Function

Function SwitchSubTitleStanza(sArray As String, bBody As Boolean) As String
	Dim l As Long, sID As String, sText As String
	sText =  &quot;&quot;
	For l = lCurrentElement To UBound(sArray)
		If sArray(l,1) = sStylePoem Then
			sText = sText &amp; MakeStanza(sArray, bBody)
		ElseIf sArray(l,1) = sStylePoemSubTitle Then &apos; чередование &lt;stanza&gt; и &lt;subtitle&gt;
		&apos;	lCurrentElement = l
			sText = sText &amp; MakeSubTitle(sArray, sStylePoemSubTitle, bMergePoemSubTitle, bBody)
		&apos;	l = lCurrentElement-1
		Else
			Exit For
		End If
		oProgressBar.setValue(l) &apos; Статусбар
	Next l
	lCurrentElement = l
	If sText &lt;&gt; &quot;&quot; Then
		SwitchSubTitleStanza = sText
	Else
		SwitchSubTitleStanza = &quot;&quot;
	End If
End Function

Function MakeStanza(sArray As String, bBody As Boolean) As String
	Dim l As Long, sID As String, sStanza As String, nC As Integer
	sStanza =  &quot;&quot;
	nC = 0 &apos; счетчик строк поэмы
	For l = lCurrentElement To UBound(sArray)
		If sArray(l,1) = sStylePoem Then
			If sArray(l,0) &lt;&gt; &quot;&quot; Then &apos; стих есть
				&apos; смотрим предыдущий элемент
				If l &gt; 0 Then
					If sArray(l-1,1) &lt;&gt; sStylePoem Then &apos; не стих - открываем stanza
						sStanza = sStanza &amp; &quot;&lt;stanza&gt;&quot; &amp; chr(10)
					End If
				ElseIf l = 0 Then
					If sArray(0,1) = sStylePoem Then &apos; стих - открываем stanza
						sStanza = sStanza &amp; &quot;&lt;stanza&gt;&quot; &amp; chr(10)
					End If
				End If
				If bDocLinks = True Then &apos; обработка ссылок внутри документа
					If FindIndexForID(l, sID, bBody) &lt;&gt; -1 Then &apos; нашли закладку (ссылку) для текущего элемента
						sStanza = sStanza &amp; &quot;&lt;v &quot; &amp; &quot;id=&quot;&quot;&quot; &amp; sID &amp; &quot;&quot;&quot;&gt;&quot; &amp; sArray(l,0) &amp; &quot;&lt;/v&gt;&quot; &amp; chr(10)
					Else &apos; для текущего элемента нет ни одной закладки (и ссылки, соответственно)
						sStanza = sStanza &amp; &quot;&lt;v&gt;&quot; &amp; sArray(l,0) &amp; &quot;&lt;/v&gt;&quot; &amp; chr(10)
					End If
				Else
					sStanza = sStanza &amp; &quot;&lt;v&gt;&quot; &amp; sArray(l,0) &amp; &quot;&lt;/v&gt;&quot; &amp; chr(10)
				End If
				&apos; смотрим следующий элемент
				If l &lt; UBound(sArray) Then
					If sArray(l+1,1) &lt;&gt; sStylePoem Then &apos; не стих - закрываем stanza
						sStanza = sStanza &amp; &quot;&lt;/stanza&gt;&quot; &amp; chr(10)
					End If
				End If
			Else &apos; пустой абзац-стих - закрываем stanza
				If nC &gt; 0 Then &apos; защита, если 1-я строка Поэму - &quot;пустая строка&quot; - НЕ ПО СХЕМЕ fb2!!!
					sStanza = sStanza &amp; &quot;&lt;/stanza&gt;&quot; &amp; chr(10)
				End If
				&apos; смотрим следующий элемент
				If l &lt; UBound(sArray) Then
					If sArray(l+1,1) = sStylePoem Then &apos; стих - открываем stanza
						sStanza = sStanza &amp; &quot;&lt;stanza&gt;&quot; &amp; chr(10)
					End If
				End If
			End If
			nC = nC + 1
		Else Exit For
		End If
	Next l
	lCurrentElement = l
	If sStanza &lt;&gt; &quot;&quot; Then
		MakeStanza = sStanza
	Else
		MakeStanza = &quot;&quot;
	End If
End Function

Function MakePoemAuthor(sArray As String, bBody As Boolean) As String
	&apos; Авторы поэмы
	Dim sPoem As String, l As Long, sID As String
	l = lCurrentElement
	If lCurrentElement &gt; UBound( sArray() ) Then Exit Function
	If sArray(lCurrentElement,1) = sStylePoemAuthor Then
		If bMergePoemAuthors = True Then &apos; собираем Авторов стиха, идущих один за другим в одну строку
			Dim nCount As Integer, nCountTag As Integer &apos; число авторов поэмы с закладками
			nCount = 0
			nCountTag = 0
			Dim sAPTag As String
			For l = lCurrentElement To UBound(sArray)
				If sArray(l,1) = sStylePoemAuthor Then
					If bDocLinks = True Then
						&apos; обработка ссылок внутри документа
						If FindIndexForID(l, sID, bBody) &lt;&gt; -1 Then &apos; нашли закладку (ссылку) для текущего элемента
							sAPTag = &quot;&lt;text-author &quot; &amp; &quot;id=&quot;&quot;&quot; &amp; sID &amp; &quot;&quot;&quot;&gt;&quot;
							nCount = nCount+1 &apos;счетчик закладок
						Else &apos; для текущего элемента нет ни одной закладки (и ссылки, соответственно)
							If nCount = 0 Then &apos; чтобы не &quot;затереть&quot; закладки вышестоящих авторов
								sAPTag = &quot;&lt;text-author&gt;&quot; &apos; нет ни одной закладки
							End If
						End If
					Else
						sAPTag = &quot;&lt;text-author&gt;&quot;
					End If
					If nCountTag = 0 Then &apos; чтобы не добавлять и другие теги &lt;text-author id=&gt;
						sPoem = sPoem &amp; sAPTag
						nCountTag = nCountTag+1 &apos;счетчик закладок
					End If
					sPoem = sPoem &amp; sArray(l,0) &amp; &quot;, &quot;
					oProgressBar.setValue(l) &apos; Статусбар
				Else Exit For
				End If
			Next l
			sPoem = Mid(sPoem, 1, Len(sPoem)-2)
			sPoem = sPoem &amp; &quot;&lt;/text-author&gt;&quot;
			lCurrentElement = l
		Else &apos; Авторы стиха не будут собираться в одну строку, а будут один под другим
			For l = lCurrentElement To UBound(sArray)
				If sArray(l,1) = sStylePoemAuthor Then
					If bDocLinks = True Then
						&apos; обработка ссылок внутри документа
						If FindIndexForID(l, sID, bBody) &lt;&gt; -1 Then &apos; нашли закладку (ссылку) для текущего элемента
							sPoem = sPoem &amp; &quot;&lt;text-author &quot; &amp; &quot;id=&quot;&quot;&quot; &amp; sID &amp; &quot;&quot;&quot;&gt;&quot; &amp; sArray(l,0) &amp; &quot;&lt;/text-author&gt;&quot; &amp; chr(10)
						Else &apos; для текущего элемента нет ни одной закладки (и ссылки, соответственно)
							sPoem = sPoem &amp; &quot;&lt;text-author&gt;&quot; &amp; sArray(l,0) &amp; &quot;&lt;/text-author&gt;&quot; &amp; chr(10)
						End If
					Else
						sPoem = sPoem &amp; &quot;&lt;text-author&gt;&quot; &amp; sArray(l,0) &amp; &quot;&lt;/text-author&gt;&quot; &amp; chr(10)
					End If
					oProgressBar.setValue(l) &apos; Статусбар
				Else Exit For
				End If
			Next l
			lCurrentElement = l
		End If
	End If
	lCurrentElement = l
	MakePoemAuthor = sPoem
End Function

Function MakePoemDate(sArray As String) As String
	Dim sSTR As String
	sSTR = &quot;&quot;
	&apos; Дата написания поэмы - согласно схемы допускается только одна дата.
	&apos; Если есть еще одна строка с датой, то она будет просто текстом (&lt;p&gt;XXX&lt;/p&gt;)
	If lCurrentElement &lt;= UBound( sArray() ) Then
		If sArray(lCurrentElement,1) = sStylePoemDate Then
			sSTR = sSTR &amp; &quot;&lt;date&gt;&quot; &amp; sArray(lCurrentElement,0) &amp; &quot;&lt;/date&gt;&quot; &amp; chr(10)
			oProgressBar.setValue(lCurrentElement) &apos; Статусбар
			lCurrentElement = lCurrentElement + 1
		End If
	End If
	MakePoemDate = sSTR
End Function

Function MakeEpigraph(sArray As String, sStyle_Epigraph, sStyle_EpigraphAuthor, bBody As Boolean) As String
	Dim sEpig As String, l As Long, sID As String
	sEpig = &quot;&quot;
	For l = lCurrentElement To UBound(sArray)
		If sArray(l,1) = sStyle_Epigraph AND sArray(l,0) &lt;&gt; &quot;&quot; Then
			&apos; Просто абзацы цитаты или пустая строка
			If bDocLinks = True Then
				&apos; обработка ссылок внутри документа
				If FindIndexForID(l, sID, bBody) &lt;&gt; -1 Then &apos; нашли закладку (ссылку) для текущего элемента
					sEpig = sEpig &amp; &quot;&lt;p &quot; &amp; &quot;id=&quot;&quot;&quot; &amp; sID &amp; &quot;&quot;&quot;&gt;&quot; &amp; sArray(l,0) &amp; &quot;&lt;/p&gt;&quot; &amp; chr(10)
				Else &apos; для текущего элемента нет ни одной закладки (и ссылки, соответственно)
					sEpig = sEpig &amp; &quot;&lt;p&gt;&quot; &amp; sArray(l,0) &amp; &quot;&lt;/p&gt;&quot; &amp; chr(10)
				End If
			Else
				sEpig = sEpig &amp; &quot;&lt;p&gt;&quot; &amp; sArray(l,0) &amp; &quot;&lt;/p&gt;&quot; &amp; chr(10)
			End If
			oProgressBar.setValue(l) &apos; Статусбар
		ElseIf sArray(l,1) = sStyle_Epigraph AND sArray(l,0) = &quot;&quot; Then
			&apos; пустые строки
			sEpig = sEpig &amp; &quot;&lt;empty-line/&gt;&quot; &amp; chr(10)
		ElseIf sArray(l,1) = sStylePoem OR sArray(l,1) = sStylePoemTitle OR _
				sArray(l,1) = sStylePoemSubTitle Then
			lCurrentElement = l
			sEpig = sEpig &amp; MakePoem(sArray, bBody)
			l = lCurrentElement-1
		ElseIf sArray(l,1) = sStyleCite OR sArray(l,1) = sStyleCiteSubTitle Then
			&apos; цитаты внутри аннотации
			lCurrentElement = l
			sEpig = sEpig &amp; MakeCite(sArray, bBody)
			l = lCurrentElement-1
		Else Exit For
		End If
	Next l
	lCurrentElement = l
	
	&apos; Авторы цитаты, если они есть
	sEpig = sEpig &amp; MakeEpigraphAuthor(sArray, sStyle_EpigraphAuthor, bBody)
	
	IF sEpig &lt;&gt; &quot;&quot; Then
		MakeEpigraph = &quot;&lt;epigraph&gt;&quot; &amp; chr(10) &amp; sEpig &amp; &quot;&lt;/epigraph&gt;&quot;
	Else
		MakeEpigraph = &quot;&quot;
	End If
End Function

Function MakeEpigraphAuthor(sArray As String, sStyle_EpigraphAuthor As String, bBody As Boolean) As String
	&apos; Авторы эпиграфа
	Dim sEpig As String, l As Long, sID As String
	l = lCurrentElement
	If lCurrentElement &gt; UBound( sArray() ) Then Exit Function
	If sArray(lCurrentElement,1) = sStyle_EpigraphAuthor Then
		If bMergeEpigraphAuthors = True Then &apos; собираем Авторов епиграфа, идущих один за другим в одну строку
			Dim nCount As Integer, nCountTag As Integer &apos; число авторов эпиграфа с закладками
			nCount = 0
			nCountTag = 0
			Dim sAETag As String
			For l = lCurrentElement To UBound(sArray)
				If sArray(l,1) = sStyle_EpigraphAuthor Then
					If bDocLinks = True Then
						&apos; обработка ссылок внутри документа
						If FindIndexForID(l, sID, bBody) &lt;&gt; -1 Then &apos; нашли закладку (ссылку) для текущего элемента
							sAETag = &quot;&lt;text-author &quot; &amp; &quot;id=&quot;&quot;&quot; &amp; sID &amp; &quot;&quot;&quot;&gt;&quot;
							nCount = nCount+1 &apos;счетчик закладок
						Else &apos; для текущего элемента нет ни одной закладки (и ссылки, соответственно)
							If nCount = 0 Then &apos; чтобы не &quot;затереть&quot; закладки вышестоящих авторов
								sAETag = &quot;&lt;text-author&gt;&quot; &apos; нет ни одной закладки
							End If
						End If
					Else
						sAETag = &quot;&lt;text-author&gt;&quot;
					End If
					If nCountTag = 0 Then &apos; чтобы не добавлять и другие теги &lt;text-author id=&gt;
						sEpig = sEpig &amp; sAETag
						nCountTag = nCountTag+1 &apos;счетчик закладок
					End If
					sEpig = sEpig &amp; sArray(l,0) &amp; &quot;, &quot;
					oProgressBar.setValue(l) &apos; Статусбар
				Else Exit For
				End If
			Next l
			sEpig = Mid(sEpig, 1, Len(sEpig)-2)
			sEpig = sEpig &amp; &quot;&lt;/text-author&gt;&quot; &amp; chr(10)
			lCurrentElement = l
		Else &apos; Авторы епиграфа не будут собираться в одну строку, а будут один под другим
			For l = lCurrentElement To UBound(sArray)
				If sArray(l,1) = sStyle_EpigraphAuthor Then
					If bDocLinks = True Then
						&apos; обработка ссылок внутри документа
						If FindIndexForID(l, sID, bBody) &lt;&gt; -1 Then &apos; нашли закладку (ссылку) для текущего элемента
							sEpig = sEpig &amp; &quot;&lt;text-author &quot; &amp; &quot;id=&quot;&quot;&quot; &amp; sID &amp; &quot;&quot;&quot;&gt;&quot; &amp; sArray(l,0) &amp; &quot;&lt;/text-author&gt;&quot; &amp; chr(10)
						Else &apos; для текущего элемента нет ни одной закладки (и ссылки, соответственно)
							sEpig = sEpig &amp; &quot;&lt;text-author&gt;&quot; &amp; sArray(l,0) &amp; &quot;&lt;/text-author&gt;&quot; &amp; chr(10)
						End If
					Else
						sEpig = sEpig &amp; &quot;&lt;text-author&gt;&quot; &amp; sArray(l,0) &amp; &quot;&lt;/text-author&gt;&quot; &amp; chr(10)
					End If
					oProgressBar.setValue(l) &apos; Статусбар
				Else Exit For
				End If
			Next l
			lCurrentElement = l
		End If
	End If
	lCurrentElement = l
	MakeEpigraphAuthor = sEpig
End Function

Function MakeAnnotation(sArray As String, bBody As Boolean) As String
	Dim sAnnot As String, l As Long, sID As String, sAnnotTag As String
	sAnnot = &quot;&lt;annotation&gt;&quot; &amp; chr(10)
	For l = lCurrentElement To UBound(sArray)
		If sArray(l,1) = sStyleAnnotation AND sArray(l,0) &lt;&gt; &quot;&quot; Then
			If bDocLinks = True Then
				&apos; обработка ссылок внутри документа
				If FindIndexForID(l, sID, bBody) &lt;&gt; -1 Then &apos; нашли закладку (ссылку) для текущего элемента
					sAnnotTag = &quot;&lt;p &quot; &amp; &quot;id=&quot;&quot;&quot; &amp; sID &amp; &quot;&quot;&quot;&gt;&quot;
				Else &apos; для текущего элемента нет ни одной закладки (и ссылки, соответственно)
					sAnnotTag = &quot;&lt;p&gt;&quot; &apos; нет ни одной закладки
				End If
			Else
				sAnnotTag = &quot;&lt;p&gt;&quot;
			End If
			sAnnot = sAnnot &amp; sAnnotTag &amp; sArray(l,0) &amp; &quot;&lt;/p&gt;&quot; &amp; chr(10)
			oProgressBar.setValue(l) &apos; Статусбар
		ElseIf sArray(l,1) = sStyleAnnotation AND sArray(l,0) = &quot;&quot; Then
			&apos; пустые строки
			sAnnot = sAnnot &amp; &quot;&lt;empty-line/&gt;&quot; &amp; chr(10)
		ElseIf sArray(l,1) = sStyleAnnotationSubTitle Then
			&apos; подзаголовки
			lCurrentElement = l
			sAnnot = sAnnot &amp; MakeSubTitle(sArray, sStyleAnnotationSubTitle, bMergeAnnotationSubTitle, bBody)
			l = lCurrentElement-1
		ElseIf sArray(l,1) = sStylePoem OR sArray(l,1) = sStylePoemTitle OR _
				sArray(l,1) = sStylePoemSubTitle Then
			&apos; поэмы внутри аннотации
			lCurrentElement = l
			sAnnot = sAnnot &amp; MakePoem(sArray, bBody)
			l = lCurrentElement-1
		ElseIf sArray(l,1) = sStyleCite OR sArray(l,1) = sStyleCiteSubTitle Then
			&apos; цитаты внутри аннотации
			lCurrentElement = l
			sAnnot = sAnnot &amp; MakeCite(sArray, bBody)
			l = lCurrentElement-1
		ElseIf sArray(l,1) = &quot;Table&quot; Then
			&apos; таблица в аннотации
			sAnnot = sAnnot &amp; sArray(l,0) &amp; chr(10)
		Else
			Exit For
		End If
	Next l
	lCurrentElement = l
	sAnnot = sAnnot &amp; &quot;&lt;/annotation&gt;&quot; &amp; chr(10)
	If bELForStartAnnot = True Then
		&apos; &quot;защита&quot; - если после аннотации идет сразу Уровень, то вставляем между ними пустую строку для валидности
		sAnnot = sAnnot &amp; &quot;&lt;empty-line/&gt;&quot;
		bELForStartAnnot = False &apos; Для всех других аннотаций - не надо!!!
	End If
	MakeAnnotation = sAnnot 
End Function

Function MakeCite(sArray As String, bBody As Boolean) As String
	Dim sCite As String, l As Long, sID As String
	sCite = &quot;&quot;
	For l = lCurrentElement To UBound(sArray)
		&apos; Просто абзацы цитаты или пустая строка
		If sArray(l,1) = sStyleCite AND sArray(l,0) &lt;&gt; &quot;&quot; Then
			If bDocLinks = True Then
				&apos; обработка ссылок внутри документа
				If FindIndexForID(l, sID, bBody) &lt;&gt; -1 Then &apos; нашли закладку (ссылку) для текущего элемента
					sCite = sCite &amp; &quot;&lt;p &quot; &amp; &quot;id=&quot;&quot;&quot; &amp; sID &amp; &quot;&quot;&quot;&gt;&quot; &amp; sArray(l,0) &amp; &quot;&lt;/p&gt;&quot; &amp; chr(10)
				Else &apos; для текущего элемента нет ни одной закладки (и ссылки, соответственно)
					sCite = sCite &amp; &quot;&lt;p&gt;&quot; &amp; sArray(l,0) &amp; &quot;&lt;/p&gt;&quot; &amp; chr(10)
				End If
			Else
				sCite = sCite &amp; &quot;&lt;p&gt;&quot; &amp; sArray(l,0) &amp; &quot;&lt;/p&gt;&quot; &amp; chr(10)
			End If
			oProgressBar.setValue(l) &apos; Статусбар
		ElseIf sArray(l,1) = sStyleCite AND sArray(l,0) = &quot;&quot; Then
			&apos; пустые строки
			sCite = sCite &amp; &quot;&lt;empty-line/&gt;&quot; &amp; chr(10)
		ElseIf sArray(l,1) = sStyleCiteSubTitle Then
			&apos; подзаголовки
			lCurrentElement = l
			sCite = sCite &amp; MakeSubTitle(sArray, sStyleCiteSubTitle, bMergeCiteSubTitle, bBody)
			l = lCurrentElement-1
		ElseIf sArray(l,1) = sStylePoem OR sArray(l,1) = sStylePoemTitle OR _
				sArray(l,1) = sStylePoemSubTitle Then
			lCurrentElement = l
			sCite = sCite &amp; MakePoem(sArray, bBody)
			l = lCurrentElement-1
		ElseIf sArray(l,1) = &quot;Table&quot; Then
			&apos; таблица в цитате
			sCite = sCite &amp; sArray(l,0) &amp; chr(10)
		Else
			Exit For
		End If
	Next l
	lCurrentElement = l
	
	&apos; Авторы цитаты, если они есть
	sCite = sCite &amp; MakeCiteAuthor(sArray, bBody)
	
	IF sCite &lt;&gt; &quot;&quot; Then
		MakeCite = &quot;&lt;cite&gt;&quot; &amp; chr(10) &amp; sCite &amp; &quot;&lt;/cite&gt;&quot;
	Else
		MakeCite = &quot;&quot;
	End If
End Function

Function MakeCiteAuthor(sArray As String, bBody As Boolean) As String
	&apos; Авторы цитаты
	Dim sCite As String, l As Long, sID As String
	l = lCurrentElement
	If lCurrentElement &gt; UBound( sArray() ) Then Exit Function
	If sArray(lCurrentElement,1) = sStyleCiteAuthor Then
		If bMergeCiteAuthors = True Then &apos; собираем Авторов цитаты, идущих один за другим в одну строку
			Dim nCount As Integer, nCountTag As Integer &apos; число авторов цитаты с закладками
			nCount = 0
			nCountTag = 0
			Dim sACTag As String
			For l = lCurrentElement To UBound(sArray)
				If sArray(l,1) = sStyleCiteAuthor Then
					If bDocLinks = True Then
						&apos; обработка ссылок внутри документа
						If FindIndexForID(l, sID, bBody) &lt;&gt; -1 Then &apos; нашли закладку (ссылку) для текущего элемента
							sACTag = &quot;&lt;text-author &quot; &amp; &quot;id=&quot;&quot;&quot; &amp; sID &amp; &quot;&quot;&quot;&gt;&quot;
							nCount = nCount+1 &apos;счетчик закладок
						Else &apos; для текущего элемента нет ни одной закладки (и ссылки, соответственно)
							If nCount = 0 Then &apos; чтобы не &quot;затереть&quot; закладки вышестоящих авторов
								sACTag = &quot;&lt;text-author&gt;&quot; &apos; нет ни одной закладки
							End If
						End If
					Else
						sACTag = &quot;&lt;text-author&gt;&quot;
					End If
					If nCountTag = 0 Then &apos; чтобы не добавлять и другие теги &lt;text-author id=&gt;
						sCite = sCite &amp; sACTag
						nCountTag = nCountTag+1 &apos;счетчик закладок
					End If
					sCite = sCite &amp; sArray(l,0) &amp; &quot;, &quot;
					oProgressBar.setValue(l) &apos; Статусбар
				Else Exit For
				End If
			Next l
			sCite = Mid(sCite, 1, Len(sCite)-2)
			sCite = sCite &amp; &quot;&lt;/text-author&gt;&quot;
			lCurrentElement = l
		Else &apos; Авторы цитаты не будут собираться в одну строку, а будут один под другим
			For l = lCurrentElement To UBound(sArray)
				If sArray(l,1) = sStyleCiteAuthor Then
					If bDocLinks = True Then
						&apos; обработка ссылок внутри документа
						If FindIndexForID(l, sID, bBody) &lt;&gt; -1 Then &apos; нашли закладку (ссылку) для текущего элемента
							sCite = sCite &amp; &quot;&lt;text-author &quot; &amp; &quot;id=&quot;&quot;&quot; &amp; sID &amp; &quot;&quot;&quot;&gt;&quot; &amp; sArray(l,0) &amp; &quot;&lt;/text-author&gt;&quot; &amp; chr(10)
						Else &apos; для текущего элемента нет ни одной закладки (и ссылки, соответственно)
							sCite = sCite &amp; &quot;&lt;text-author&gt;&quot; &amp; sArray(l,0) &amp; &quot;&lt;/text-author&gt;&quot; &amp; chr(10)
						End If
					Else
						sCite = sCite &amp; &quot;&lt;text-author&gt;&quot; &amp; sArray(l,0) &amp; &quot;&lt;/text-author&gt;&quot; &amp; chr(10)
					End If
					oProgressBar.setValue(l) &apos; Статусбар
				Else Exit For
				End If
			Next l
			lCurrentElement = l
		End If
	End If
	lCurrentElement = l
	MakeCiteAuthor = sCite
End Function	
	
Function MakeSubtitle(sArray As String, sStyle_SubTitle As String, bMerge_SubTitle As String, bBody As Boolean) As String
	Dim sSubtitle As String, l As Long, sSubTag As String, sID As String
	If bMerge_SubTitle = True Then &apos; собираем подзаголовки, идущие один за другим в одну строку
		Dim nCount As Integer &apos; число подзаголовков с закладками
		nCount = 0
		For l = lCurrentElement To UBound(sArray)
			If sArray(l,1) = sStyle_SubTitle Then
				If bDocLinks = True Then
					&apos; обработка ссылок внутри документа
					If FindIndexForID(l, sID, bBody) &lt;&gt; -1 Then &apos; нашли закладку (ссылку) для текущего элемента
						sSubTag = &quot;&lt;subtitle &quot; &amp; &quot;id=&quot;&quot;&quot; &amp; sID &amp; &quot;&quot;&quot;&gt;&quot;
						nCount = nCount+1 &apos;счетчик закладок
					Else &apos; для текущего элемента нет ни одной закладки (и ссылки, соответственно)
						If nCount = 0 Then &apos; чтобы не &quot;затереть&quot; закладки вышестоящих подзаголовков
							sSubTag = &quot;&lt;subtitle&gt;&quot; &apos; нет ни одной закладки
						End If
					End If
				Else
					sSubTag = &quot;&lt;subtitle&gt;&quot;
				End If
				sSubtitle = sSubtitle &amp; sArray(l,0) &amp; &quot; &quot;
				oProgressBar.setValue(l) &apos; Статусбар
			Else Exit For
			End If
		Next l
		lCurrentElement = l
		If sSubTag &lt;&gt; &quot;&quot; AND sSubtitle &lt;&gt; &quot;&quot; Then
			sSubtitle = sSubTag &amp; Trim(sSubtitle) &amp; &quot;&lt;/subtitle&gt;&quot; &amp; chr(10)
		End If
	Else &apos; подзаголовки не будут собираться в одну строку, а будут один под другим
		For l = lCurrentElement To UBound(sArray)
			If sArray(l,1) = sStyle_SubTitle Then
				If bDocLinks = True Then
					&apos; обработка ссылок внутри документа
					If FindIndexForID(l, sID, bBody) &lt;&gt; -1 Then &apos; нашли закладку (ссылку) для текущего элемента
						sSubtitle = sSubtitle &amp; &quot;&lt;subtitle &quot; &amp; &quot;id=&quot;&quot;&quot; &amp; sID &amp; &quot;&quot;&quot;&gt;&quot; &amp; sArray(l,0) &amp; &quot;&lt;/subtitle&gt;&quot; &amp; chr(10)
					Else &apos; для текущего элемента нет ни одной закладки (и ссылки, соответственно)
						sSubtitle = sSubtitle &amp; &quot;&lt;subtitle&gt;&quot; &amp; sArray(l,0) &amp; &quot;&lt;/subtitle&gt;&quot; &amp; chr(10)
					End If
				Else
					sSubtitle = sSubtitle &amp; &quot;&lt;subtitle&gt;&quot; &amp; sArray(l,0) &amp; &quot;&lt;/subtitle&gt;&quot; &amp; chr(10)
				End If
				oProgressBar.setValue(l) &apos; Статусбар
			Else Exit For
			End If
		Next l
		lCurrentElement = l
	End If
	MakeSubtitle = sSubtitle
End Function

Function MakeSection(sArray As String, sLevel As String, bBody As Boolean) As String
	Dim sSect As String, sSectTag As String
	If bDocLinks = True Then
		&apos; обработка ссылок внутри документа
		Dim sID As String
		If FindIndexForID(lCurrentElement, sID, bBody) &lt;&gt; -1 Then &apos; нашли закладку (ссылку) для текущего элемента
			sSectTag = &quot;&lt;section &quot; &amp; &quot;id=&quot;&quot;&quot; &amp; sID &amp; &quot;&quot;&quot;&gt;&quot; &amp; chr(10) &amp; &quot;&lt;title&gt;&quot; &amp; chr(10)
		Else &apos; для текущего элемента нет ни одной закладки (и ссылки, соответственно)
			sSectTag = &quot;&lt;section&gt;&quot; &amp; chr(10) &amp; &quot;&lt;title&gt;&quot; &amp; chr(10)
		End If
	Else
		sSectTag = &quot;&lt;section&gt;&quot; &amp; chr(10) &amp; &quot;&lt;title&gt;&quot; &amp; chr(10)
	End If
	sSect = sSectTag &amp; sArray(lCurrentElement,0) &amp; chr(10) &amp; &quot;&lt;/title&gt;&quot;
	oProgressBar.setValue(lCurrentElement) &apos; Статусбар
	lCurrentElement = lCurrentElement+1
	MakeSection = sSect
End Function

&apos; поиск номера(индекса) абзаца из массива sLinksTo, соответствующему текущему элементу из sParaStyleName (если такое соответствие есть)
Function FindIndexForID( lCurElement As Long, sID As String, bBody As Boolean ) As Long
	FindIndexForID = -1
	If bBody = False Then &apos; ссылки только для основного текста книги, а не для сносок
		Exit Function
	End If
	Dim l As Long
	For l=0 To UBound(sLinksTo)
		If sLinksTo(l,0) = lCurElement Then
			FindIndexForID = sLinksTo(l,0)
			sID = sLinksTo(l,1)
			Exit For
		End If
	Next l
End Function

</script:module>