<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE script:module PUBLIC "-//OpenOffice.org//DTD OfficeDocument 1.0//EN" "module.dtd">
<script:module xmlns:script="http://openoffice.org/2000/script" script:name="Body" script:language="StarBasic">REM  *****  BASIC  *****
Option Explicit

Public bELForStartAnnot As Boolean
Public asFNPars() As String &apos; массив абзацев сноски с ее &quot;аттрибутами&quot; (для печати)

Function IsAECP( sStyle As String ) As Boolean
	&apos; Если sStyle - это Эпиграф, Цитата или Поэма - то возвращается True, иначе - False
	Select Case sStyle
			Case sStylePoem
				IsAECP = True
			Case sStylePoemTitle
				IsAECP = True
			Case sStylePoemSubTitle
				IsAECP = True
			Case sStylePoemAuthor
				IsAECP = True
			Case sStylePoemDate
				IsAECP = True
			Case sStyleCite
				IsAECP = True
			Case sStyleCiteSubTitle
				IsAECP = True
			Case sStyleCiteAuthor
				IsAECP = True
			Case sStyleEpigraph
				IsAECP = True
			Case sStyleEpigraphAuthor
				IsAECP = True
			Case sStyleAnnotationSubTitle
				IsAECP = True
			Case Else
				IsAECP = False
	End Select
End Function

Sub SaveBody()
	If  IsLevel(sBodyParagraphs(UBound(sBodyParagraphs),1)) = True OR _
		IsAECP(sBodyParagraphs(UBound(sBodyParagraphs),1)) = True Then
		&apos; Защита от &quot;вылетания&quot; конвертора, на случай, если последний абзац - 
		&apos; Уровень (в нарушение схемы), Эпиграф (в нарушение схемы), Поэма, Цитата
	 	&apos; значительно упрощаются функции создания сложных Поэм, Цитата и т.д. -
	 	&apos; Убирается масса проверок на верхний граничный индекс - увеличивается быстродействие конвертора!
		AddBodyArray( &quot;&lt;empty-line/&gt;&quot;, &quot;&quot;, False )
	End If

	lCurrentElement = 0
	oTextOutputStream.writeString( MakeBookTitle )
	
	MakeBody( sBodyParagraphs(), True )
End Sub

Function Save1OpenSectionForCandidate( sArray() As String, lCurrentElement As Long, bTextSmSection As Boolean )
	Save1OpenSectionForCandidate = False
	&apos; печать 1 открывающей секции для кандидатов в обрамление &lt;section&gt;...&lt;/section&gt; для уровней, вида 1,текст,2; 1,текст,5
	If IsCandidateToSections( sArray(), lCurrentElement ) Then
		&apos; возможные кандидаты на обрамление &lt;sections&gt;...&lt;/sections&gt; для уровней, вида 1,текст,2; 1,текст,5
		If bTextSmSection = False Then
			oTextOutputStream.writeString(&quot;&lt;section&gt;&quot; &amp; chr(10))
			bTextSmSection = True
			Save1OpenSectionForCandidate = True
		End If
	End If
End Function

&apos; печать заданного числа открывающих &lt;section&gt;
Sub SaveNOpenSections( N As Integer )
	If N &gt; 0 Then
		Dim i As Integer
		For i=0 To N-1
			oTextOutputStream.writeString( &quot;&lt;section&gt;&quot; &amp; chr(10) )
		Next i
	End If
End Sub

Function IsCandidateToSections( sArray() As String, lCurrentElement As Long )
	&apos; возможные кандидаты на обрамление &lt;sections&gt;...&lt;/sections&gt; для уровней, вида 1,текст,2; 1,текст,5
	IsCandidateToSections = False
	Dim sElement As String : sElement = sArray(lCurrentElement,1)
	If sElement=&quot;Para&quot; _
		OR sElement=sStylePoem Or sElement=sStylePoemTitle Or sElement=sStylePoemSubTitle Or sElement=sStylePoemAuthor _
		OR sElement=sStyleCite Or sElement=sStyleCiteSubTitle Or sElement=sStyleCiteAuthor _
		OR sElement=sStyleSubTitle OR sElement=&quot;Image&quot; OR sElement=&quot;Table&quot; OR sElement=&quot;&quot; _
		 Then
			IsCandidateToSections = True
	End If
End Function

Sub SaveNotes()
	lCurrentElement = 0
	Dim oFootNotes	: oFootNotes	= ThisComponent.getFootnotes()
	Dim oEndNotes	: oEndNotes		= ThisComponent.getEndnotes()
	Dim lCount		As Long
	Dim vaFNPara()	As Variant
	
	If bFENoteSeparately = True Then
		&apos; экспорт сносок и концевых сносок в разные блоки
		If oFootNotes.getCount() &gt; 0 Then
			&apos; сохраняем сноски
			oTextOutputStream.writeString(&quot;&lt;body name=&quot;&quot;notes&quot;&quot;&gt;&quot; &amp; chr(10))
			oTextOutputStream.writeString(&quot;&lt;title&gt;&quot; &amp; chr(10) &amp; &quot;&lt;p&gt;&quot; &amp; sFootnoteTitle &amp; &quot;&lt;/p&gt;&quot; &amp; chr(10) &amp; &quot;&lt;/title&gt;&quot; &amp; chr(10))
			For lCount = 0 To UBound(vFootnoteText())
				vaFNPara() = vFootnoteText( lCount ) : vaFNPara() = vaFNPara(0)
				If vaFNPara(0,3) = &quot;FootNote&quot; Then SaveNote( &quot;n&quot;, vaFNPara(), lCount )
			Next lCount
			oTextOutputStream.writeString(&quot;&lt;/body&gt;&quot; &amp; chr(10))
		End If
		If oEndNotes.getCount() &gt; 0 Then
			&apos; сохраняем концевые сноски
			oTextOutputStream.writeString(&quot;&lt;body name=&quot;&quot;comments&quot;&quot;&gt;&quot; &amp; chr(10))
			oTextOutputStream.writeString(&quot;&lt;title&gt;&quot; &amp; chr(10) &amp; &quot;&lt;p&gt;&quot; &amp; sENTitle &amp; &quot;&lt;/p&gt;&quot; &amp; chr(10) &amp; &quot;&lt;/title&gt;&quot; &amp; chr(10))
			For lCount = 0 To UBound(vEndnoteText())
				vaFNPara() = vEndnoteText( lCount ) : vaFNPara() = vaFNPara(0)
				If vaFNPara(0,3) = &quot;EndNote&quot; Then SaveNote( &quot;c&quot;, vaFNPara(), lCount )
			Next lCount
			oTextOutputStream.writeString(&quot;&lt;/body&gt;&quot; &amp; chr(10))
		End If
	Else
		&apos; экспорт сносок и концевых сносок в общий блок
		oTextOutputStream.writeString(&quot;&lt;body name=&quot;&quot;notes&quot;&quot;&gt;&quot; &amp; chr(10))
		oTextOutputStream.writeString(&quot;&lt;title&gt;&quot; &amp; chr(10) &amp; &quot;&lt;p&gt;&quot; &amp; sFootnoteTitle &amp; &quot;&lt;/p&gt;&quot; &amp; chr(10) &amp; &quot;&lt;/title&gt;&quot; &amp; chr(10))
		For lCount = 0 To UBound(vFootnoteText())
			vaFNPara() = vFootnoteText( lCount ) : vaFNPara() = vaFNPara(0)
			SaveNote( &quot;n&quot;, vaFNPara(), lCount )
		Next lCount
		oTextOutputStream.writeString(&quot;&lt;/body&gt;&quot; &amp; chr(10))	
	End If
End Sub

Sub SaveNote( idSymbol As String, ByRef vaFNPara() As Variant, lCount As Long )
	Dim sNote As String, sType As String, sBookMark As String, sFNType As String
	oTextOutputStream.writeString(&quot;&lt;section id=&quot;&quot;&quot; &amp; idSymbol &amp; &quot;&quot; &amp; lCount+1 &amp; &quot;&quot;&quot;&gt;&quot; &amp; chr(10))
&apos;	oTextOutputStream.writeString(&quot;&lt;section id=&quot;&quot;n&quot; &amp; lCount+1 &amp; &quot;&quot;&quot;&gt;&quot; &amp; chr(10))
	oTextOutputStream.writeString(&quot;&lt;title&gt;&quot; &amp; chr(10) &amp; &quot;&lt;p&gt;&quot; &amp; lCount+1 &amp; &quot;&lt;/p&gt;&quot; &amp; chr(10) &amp; &quot;&lt;/title&gt;&quot; &amp; chr(10))
	&apos; по всем абзацам каждой сноски
	Redim asFNPars() As String
	Dim lParaCount As Long
	For lParaCount = 0 To UBound( vaFNPara() )
		sNote		= vaFNPara( lParaCount, 0 )
		sType		= vaFNPara( lParaCount, 1 )
		sBookMark	= vaFNPara( lParaCount, 2 )
		sFNType		= vaFNPara( lParaCount, 3 )
		AddNewItemToArray4( asFNPars(), sNote, sType, sBookMark, sFNType )
	Next lParaCount
	lCurrentElement = 0
	&apos; Защита от &quot;вылетания&quot; конвертора, на случай, если последний абзац - Уровень, Эпиграф, Поэма, Цитата (в нарушение схемы)
	&apos; значительно упрощаются функции создания сложных Поэм, Цитата и т.д. -
 	&apos; Убирается масса проверок на верхний граничный индекс - увеличивается быстродействие конвертора!
	AddNewItemToArray4( asFNPars(), &quot;&quot;, &quot;end-fn&quot;, &quot;&quot;, &quot;&quot;) &apos; иначе тип последней строки сноски определяется неверно
	MakeBody( asFNPars(), False )

	oTextOutputStream.writeString(&quot;&lt;/section&gt;&quot; &amp; chr(10))
	oProgressBar.setValue(lCount) &apos; Статусбар
End Sub

&apos; печатаем коды картинок
Function SaveImages() As Integer
	If( UBound( Images() )&gt;=0 ) Then
		Dim i As Integer, j As Integer
		j = 0
		For i=0 To UBound( Images() )
			Dim sMimeFile As String : sMimeFile = getOOoFBToolsTempPath() &amp; &quot;/base64image&quot; &amp; i &amp; &quot;.txt&quot;
			If FileExists( sMimeFile ) Then
				&apos; для jpg-файлов приводим mime-тип к правильному значению
				Dim sExt As String : sExt = Images(i)
				Dim sFileExt As String : sFileExt = Images(i)
				sFileExt = Images(i)
				If LCase(sExt) = &quot;jpg&quot; Then
					sFileExt = &quot;jpeg&quot;
				End If

				&apos; считываем код картинки из файла		
				Dim sLine As String
				Dim oSFA As Object, oFS As Object, oTIS As Object
				oSFA = createUnoService (&quot;com.sun.star.ucb.SimpleFileAccess&quot;)
				oFS = oSFA.openFileRead ( ConvertToURL ( sMimeFile ) )
				oTIS = createUnoService (&quot;com.sun.star.io.TextInputStream&quot;)
				oTIS.setInputStream (oFS)
				If Not IsFileEmpty( sMimeFile ) Then
					&apos; открываем тэг
					oTextOutputStream.writeString( &quot;&lt;binary id=&quot;&quot;img_&quot; &amp; i &amp; &quot;.&quot; &amp; sExt &amp; &quot;&quot;&quot; content-type=&quot;&quot;image/&quot; &amp; sFileExt &amp; &quot;&quot;&quot;&gt;&quot; &amp; chr(10) )
					Do While ( NOT oTIS.isEOF() )
						sLine = oTIS.readLine()
						If sLine &lt;&gt; chr(10) Then
							If sLine &lt;&gt; &quot;&quot; Then
								oTextOutputStream.writeString( sLine &amp; chr(10) )
							End If
						End If
					Loop
					oTIS.closeInput()
					&apos; закрываем тэг
					oTextOutputStream.writeString( &quot;&lt;/binary&gt;&quot; &amp; chr(10) )
					j = j+1
				End If
			End If
			oProgressBar.setValue(i) &apos; Статусбар
		Next i
	End If
	SaveImages = j
End Function

Function IsNeededELForAnnot( sArray() As String, ByVal lCurrentElement As Long ) As Boolean
	&apos; &quot;защита&quot; - если после аннотации идет сразу Уровень, то вставляем между ними пустую строку для валидности
	Dim l As Long, lPointer As Long
	lPointer = lCurrentElement
	For l=0 To UBound(sArray())
		If sArray(lPointer,1)&lt;&gt;sStyleAnnotation Then
			If sArray(lPointer,1)=&quot;&quot; Then &apos; пустая строка после стартовой аннотации уже есть
				If bDelEL = True Then &apos; не удаляем пустую строку, даже при включенной опции удаления
					IsNeededELForAnnot = True				
				Else
					IsNeededELForAnnot = False
				End If
				Exit Function
			ElseIf IsLevel(sArray(lPointer,1)) = True Then
				IsNeededELForAnnot = True
				Exit Function
			Else
				IsNeededELForAnnot = False
				Exit Function
			End If
		End If
		lPointer = lPointer+1
	Next l
	IsNeededELForAnnot = False
End Function

Sub MakeBody( sArray() As String, bBody As Boolean )
	&apos; 1. Печать абзацев, находящихся до 1-й секции (если они есть)
	&apos; Проверка на наличие Annotation, Cite, Poem Title, Poem, Para, &quot;&quot; (&lt;empty-line&gt;).
	&apos; Если есть, то до них ставим &lt;section&gt;, а перед 1-й секцией &lt;/section&gt;. Epigraph - без &lt;section&gt;...&lt;/section&gt;
	Dim lParaCount			As Long		: lParaCount			= UBound(sArray())
	Dim lIndexOfBookTitle	As Long		: lIndexOfBookTitle		= IndexOfBookTitle( sArray() )
	&apos; ищем 1-й Заголовой любого Уровня только тот, который после Названия Книги!!!
	Dim lIndexOf1Section	As Long
	If lIndexOfBookTitle &lt;&gt; -1 Then &apos; если в тексте нет стиля Book Title
		lIndexOf1Section = IndexOf1Section( sArray(), lIndexOfBookTitle )
	Else							&apos; если стиль Book Title в тексте есть
		lIndexOf1Section = IndexOf1Section( sArray(), 0 )
	End If
	Dim lIndexOfEndSection	As Long		: lIndexOfEndSection	= IndexOfEndSection( sArray() )
	Dim bText				As Boolean	: bText					= False
	Dim bTextSmSection		As Boolean	: bTextSmSection		= False
	
	If lIndexOf1Section = -1 Then &apos; нет ни одной секции
		While sArray(lCurrentElement,1)=sStyleEpigraph
			&apos; Если 1-е элементы - епиграф, то его не берем в &lt;section&gt;, хотя если взять - документ все равно валидный будет
			SaveElements(sArray, sArray(lCurrentElement, 1), sArray(lCurrentElement, 0), bBody)
			If bBody Then oProgressBar.setValue(lCurrentElement) &apos; Статусбар
&apos;			If lCurrentElement &gt; UBound( sArray() ) Then Exit Function
		Wend
		&apos; Все остальные элементы обрамляем &lt;section&gt;
		If bBody = True Then &apos; только для body книги (не для сносок - лишняя секция)
			oTextOutputStream.writeString(&quot;&lt;section&gt;&quot; &amp; chr(10))
		End If
		While lCurrentElement &lt;= UBound(sArray)
			SaveElements(sArray, sArray(lCurrentElement, 1), sArray(lCurrentElement, 0), bBody)
			If bBody Then oProgressBar.setValue(lCurrentElement) &apos; Статусбар
		Wend
		If bBody = True Then &apos; только для body книги (не для сносок - лишняя секция)
			oTextOutputStream.writeString(&quot;&lt;/section&gt;&quot; &amp; chr(10))
		End If
	Else &apos;секции есть
		If lIndexOf1Section &gt; 0 Then &apos; что-то есть - записываем до 1-й секции
			While lCurrentElement &lt; lIndexOf1Section
				If sArray(lCurrentElement,1)=&quot;Para&quot; OR _
					sArray(lCurrentElement,1)=sStylePoemTitle OR sArray(lCurrentElement,1)=sStylePoem OR sArray(lCurrentElement,1)=sStylePoemSubTitle OR _
					sArray(lCurrentElement,1)=sStyleCiteSubTitle OR sArray(lCurrentElement,1)=sStyleCite OR _
					sArray(lCurrentElement,1)=sStyleSubTitle OR sArray(lCurrentElement,1)=&quot;&quot; OR _
					sArray(lCurrentElement,1)=&quot;Image&quot; OR sArray(lCurrentElement,1)=&quot;Table&quot; OR _
					sArray(lCurrentElement,1)=sStyleAnnotation Then
					If bText = False Then
						oTextOutputStream.writeString(&quot;&lt;section&gt;&quot; &amp; chr(10))
						bText = True
						&apos; &quot;защита&quot; - если после аннотации идет сразу Уровень, то вставляем между ними пустую строку для валидности
						If sArray(lCurrentElement,1)=sStyleAnnotation Then
							bELForStartAnnot = IsNeededELForAnnot( sArray(), lCurrentElement )
						End If
					End If
					SaveElements(sArray, sArray(lCurrentElement, 1), sArray(lCurrentElement, 0), bBody)
					If bBody Then oProgressBar.setValue(lCurrentElement) &apos; Статусбар
				Else &apos; это явно эпиграф
					If bText = True Then
						oTextOutputStream.writeString(&quot;&lt;/section&gt;&quot; &amp; chr(10))
						SaveElements(sArray, sArray(lCurrentElement, 1), sArray(lCurrentElement, 0), bBody)
						bText = False
					Else &apos; епиграф самый первый, как и должен 
						SaveElements(sArray, sArray(lCurrentElement, 1), sArray(lCurrentElement, 0), bBody)
					End If
					If bBody Then oProgressBar.setValue(lCurrentElement) &apos; Статусбар
				End If
				If bText = True AND lCurrentElement = lIndexOf1Section Then
					oTextOutputStream.writeString(&quot;&lt;/section&gt;&quot; &amp; chr(10))
				End If
			Wend
		End If

		&apos; 2. Печать всех блоков секций, начиная от 1-й
		If lIndexOf1Section &lt;&gt; -1 Then &apos; секция есть
			&apos; 2.1 Печать блока секции для 1-го Заголовка (Уровня)
			Dim nH1Index As Integer : nH1Index = lCurrentElement
			Dim nH2Index As Integer : nH2Index = GetIndexOfNextLevel(sArray, lCurrentElement)
			Dim nH1Level As Integer : nH1Level = GetLevelNumber( sArray(nH1Index,1) )
			Dim nH2Level As Integer
			If nH2Index = -1 Then
				nH2Level = 0
			Else
				nH2Level = GetLevelNumber( sArray(nH2Index,1) )
			End If
			
			Dim nOpenSections : nOpenSections = nH1Level &apos; число открывающих &lt;section&gt;
			
			If nH2Level &lt;&gt; 0 Then &apos; если есть 2-й Заголовок
				If nH1Level &lt; nH2Level Then
					&apos; Уровень 1-го Заголовка &lt; Уровня 2-го (например: 1 и 2; 1 и 3; 2 и 4)
					SaveNOpenSections( nOpenSections-1 ) &apos; печать заданного числа открывающих &lt;section&gt;
					SaveElements(sArray, sArray(lCurrentElement, 1), sArray(lCurrentElement, 0), bBody) &apos; печатаем Заголовок
					&apos; есть ли текст между этими Заголовками?
					If IsTextBetween2Levels( sArray(), nH1Index, nH2Index ) = True Then
						&apos; между ними есть текст - печатаем этот текст
						While lCurrentElement &lt; nH2Index
							&apos; печать 1 открывающей секции для кандидатов в обрамление &lt;section&gt;...&lt;/section&gt; для уровней, вида 1,текст,2; 1,текст,5, если кандидаты есть
							Save1OpenSectionForCandidate( sArray(), lCurrentElement, bTextSmSection )
							SaveElements(sArray, sArray(lCurrentElement, 1), sArray(lCurrentElement, 0), bBody)
						Wend
						&apos; закрываем секцию для кандидатов, если они есть
						If bTextSmSection = True Then SaveCloseSection(1)
					End If
					Dim nStep : nStep = nH2Level - nH1Level &apos; шаг между Уровнями 2-х первых Заголовков
					SaveNOpenSections( nStep-1 ) &apos; печать заданного числа открывающих &lt;section&gt;
				ElseIf nH1Level &gt; nH2Level Then
					&apos; Уровень 1-го Заголовка &gt; Уровня 2-го (например: 2 и 1; 6 и 2)
					SaveNOpenSections( nOpenSections-1 ) &apos; печать заданного числа открывающих &lt;section&gt;
					SaveElements(sArray, sArray(lCurrentElement, 1), sArray(lCurrentElement, 0), bBody) &apos; печатаем Заголовок
					&apos; есть ли текст между этими Заголовками?
					If IsTextBetween2Levels( sArray(), nH1Index, nH2Index ) = False Then
						&apos; между ними нет текста - печатаем пустую строку
						oTextOutputStream.writeString(&quot;&lt;empty-line/&gt;&quot; &amp; chr(10)) &apos; иначе - не валидность
					Else
						&apos; между ними есть текст - печатаем этот текст
						While lCurrentElement &lt; nH2Index
							SaveElements(sArray, sArray(lCurrentElement, 1), sArray(lCurrentElement, 0), bBody)
						Wend
					End If
					SaveCloseSection( nOpenSections ) &apos; закрываем &lt;/section&gt;
					&apos; для 2-го Заголовка печатаем недостающие открывающие &lt;section&gt;
					SaveNOpenSections( nH2Level-1 ) &apos; печать заданного числа открывающих &lt;section&gt;
				Else
					&apos; Уровень 1-го Заголовка = Уровню 2-го (например: 3 и 3; 1 и 1)
					SaveNOpenSections( nOpenSections-1 ) &apos; печать заданного числа открывающих &lt;section&gt;
					SaveElements(sArray, sArray(lCurrentElement, 1), sArray(lCurrentElement, 0), bBody) &apos; печатаем Заголовок
					&apos; есть ли текст между этими Заголовками?
					If IsTextBetween2Levels( sArray(), nH1Index, nH2Index ) = True Then
						While lCurrentElement &lt; nH2Index
							SaveElements(sArray, sArray(lCurrentElement, 1), sArray(lCurrentElement, 0), bBody)
						Wend
					End If
					SaveCloseSection( 1 ) &apos; закрываем &lt;/section&gt;
				End If
			Else
				&apos; в книге только 1 Заголовок
				SaveNOpenSections( nOpenSections-1 ) &apos; печать заданного числа открывающих &lt;section&gt;
				SaveElements(sArray, sArray(lCurrentElement, 1), sArray(lCurrentElement, 0), bBody) &apos; печатаем Заголовок
				If IsTextBetween2Levels( sArray(), nH1Index, lParaCount ) = False Then
					&apos; между 1-м Заголовком и последним абзацем нет текста - печатаем пустую строку
					oTextOutputStream.writeString(&quot;&lt;empty-line/&gt;&quot; &amp; chr(10)) &apos; иначе - не валидность
				Else
					Do
						SaveElements(sArray, sArray(lCurrentElement, 1), sArray(lCurrentElement, 0), bBody)
					Loop While ( lCurrentElement &lt;= lParaCount )
				End If
				SaveCloseSection( nH1Level ) &apos; закрываем &lt;/section&gt;
				If bBody Then oProgressBar.setValue(lCurrentElement) &apos; Статусбар
				Exit Sub
			End If
			If bBody Then oProgressBar.setValue(lCurrentElement) &apos; Статусбар
			
			&apos; 2.2 Печать остальных блоков секций, начиная от 2-й
			Dim lIndexOfCurrentLevel As Long, lIndexOfNextLevel As Long
			Dim nCurrentLevel As Integer, nNextLevel As Integer			
			While lCurrentElement &lt;= lParaCount &apos; по индексам
				lIndexOfCurrentLevel	= lCurrentElement &apos; индекс текущего уровня
				lIndexOfNextLevel		= GetIndexOfNextLevel( sArray(), lCurrentElement ) &apos; индекс следующего уровня
				nCurrentLevel	= GetLevelNumber( sArray(lIndexOfCurrentLevel,1) )
				If lIndexOfNextLevel = -1 Then
					nNextLevel = lIndexOfEndSection
				Else
					nNextLevel = GetLevelNumber( sArray(lIndexOfNextLevel,1) )
				End If
				If lIndexOfNextLevel = -1 Then lIndexOfNextLevel = lParaCount + 1
				bTextSmSection = False &apos; для вставки &lt;section&gt; после &lt;title&gt; уровня
				While lCurrentElement &lt; lIndexOfNextLevel
					&apos; печатаем все абзацы между секциями (саму следующую секцию не включаем)
					&apos; печатаем Заголовок
					SaveElements(sArray, sArray( lIndexOfCurrentLevel, 1), sArray(lIndexOfCurrentLevel, 0), bBody )
					Dim NN As Integer : NN = IsAdjacentCurrentLevelsOfNextLevel( sArray(), lIndexOfCurrentLevel )
					&apos; NN: знак (+ или -) показывает переход вправо с большего на меньший (напр: 5 и 2) уровень (-) или с меньшего на больший (напр: 1 и 2) уровень (+)
					&apos; 10 - если lIndexOfCurrentLevel вышел за правую границу массива (все уже обработали)
					&apos;  5 - нет следующего уровня, есть только текущий (либо в книге всего 1 Заголовок, либо текущий - последний Заголовок)
					&apos;  0 - текущий и следующий уровни - одного ранга, шаг = 0 (напр. 3 и 3)
					&apos;  1 - текущий и следующий уровни - смежные, шаг = -1 (напр. 1 и 2)
					&apos; -1 - текущий и следующий уровни - смежные, шаг = 1 (напр. 2 и 1)
					&apos;  2 - текущий и следующий уровни - не смежные, шаг &lt; -1 (напр. 1 и 4 - шаг=-3)
					&apos; -2 - текущий и следующий уровни - не смежные, шаг &gt; 1 (напр. 4 и 1 - шаг=3)
					If NN = 5 Then	&apos; нет следующего уровня, есть только текущий, который и является последним Заголовком
						&apos; печатем текст (элементы структуры) до конца книги
						If IsTextBetween2Levels( sArray(), lIndexOfCurrentLevel, lIndexOfNextLevel ) = False Then
							&apos; между ними нет текста - печатаем пустую строку
							oTextOutputStream.writeString(&quot;&lt;empty-line/&gt;&quot; &amp; chr(10)) &apos; иначе - не валидность
						Else
							&apos; между ними есть текст - печатаем этот текст
							While lCurrentElement &lt; lIndexOfNextLevel
								SaveElements(sArray, sArray(lCurrentElement, 1), sArray(lCurrentElement, 0), bBody)
							Wend
						End If
						SaveCloseSection( nCurrentLevel ) &apos; закрываем &lt;/section&gt;
					Else &apos; следующий уровень есть
						&apos; Какое направление: с меньшего на больший (1,2) или с большнго на меньший (3,1), или это - уровни одного ранга?
						If NN = 0 Then
							&apos; текущий Заголовок и следующих - уровни одного ранга (1 и 1; 5 и 5)
							&apos; есть ли текст между этими Заголовками одного ранга?
							If IsTextBetween2Levels( sArray(), lIndexOfCurrentLevel, lIndexOfNextLevel ) = True Then
								While lCurrentElement &lt; lIndexOfNextLevel
									SaveElements(sArray, sArray(lCurrentElement, 1), sArray(lCurrentElement, 0), bBody)
								Wend
							End If
							SaveCloseSection( 1 ) &apos; закрываем &lt;/section&gt;
						ElseIf NN &gt; 0 Then	&apos; направление с меньшего к большему (1 и 2; 2 и 5)
							&apos; смежные ли эти уровни?
							If NN = 1 Then 	&apos; смежные
								&apos; есть ли текст между ними?
								If IsTextBetween2Levels( sArray(), lIndexOfCurrentLevel, lIndexOfNextLevel ) = False Then
									&apos; между смежными уровнями текста нет (1,2) - чисто смежные уровни
									&apos; печать заданного числа открывающих &lt;section&gt; для Следующего Заголовка
									SaveNOpenSections( (nNextLevel - nCurrentLevel)-1 )
								Else &apos; текст между смежными уровнями есть (1-text-2)
									While lCurrentElement &lt; lIndexOfNextLevel
										&apos; печать 1 открывающей секции для кандидатов в обрамление &lt;section&gt;...&lt;/section&gt; для уровней, вида 1,текст,2; 1,текст,5, если кандидаты есть
										Save1OpenSectionForCandidate( sArray(), lCurrentElement, bTextSmSection )
										SaveElements( sArray(), sArray(lCurrentElement, 1), sArray(lCurrentElement, 0), bBody )
									Wend
									&apos; закрываем секцию для кандидатов, если они есть
									If bTextSmSection = True Then SaveCloseSection(1)
									&apos; печать заданного числа открывающих &lt;section&gt; для Следующего Заголовка
									SaveNOpenSections( (nNextLevel - nCurrentLevel)-1 )
								End If
							Else &apos; не смежные, NN = 2
								&apos; есть ли текст между ними?
								If IsTextBetween2Levels( sArray(), lIndexOfCurrentLevel, lIndexOfNextLevel ) = False Then
									&apos; между не смежными уровнями текста нет (1,4)
									SaveNOpenSections( (nNextLevel - nCurrentLevel)-1 ) &apos; печать заданного числа открывающих &lt;section&gt; для Следующего Заголовка
								Else &apos; текст между не смежными уровнями есть (1-text-3)
									While lCurrentElement &lt; lIndexOfNextLevel
										&apos; печать 1 открывающей секции для кандидатов в обрамление &lt;section&gt;...&lt;/section&gt; для уровней, вида 1,текст,2; 1,текст,5, если кандидаты есть
										Save1OpenSectionForCandidate( sArray(), lCurrentElement, bTextSmSection )
										SaveElements( sArray(), sArray(lCurrentElement, 1), sArray(lCurrentElement, 0), bBody )
									Wend
									&apos; закрываем секцию для кандидатов, если они есть
									If bTextSmSection = True Then SaveCloseSection(1)
									&apos; печать заданного числа открывающих &lt;section&gt; для Следующего Заголовка
									SaveNOpenSections( (nNextLevel - nCurrentLevel)-1 )
								End If
							End If
						Else &apos; направление с большего к меньшему (2 и 1; 5 и 3) - NN &lt; 0
							&apos; есть ли текст между этими Заголовками?
							If IsTextBetween2Levels( sArray(), lIndexOfCurrentLevel, lIndexOfNextLevel ) = False Then
								&apos; между ними нет текста - печатаем пустую строку
								oTextOutputStream.writeString(&quot;&lt;empty-line/&gt;&quot; &amp; chr(10)) &apos; иначе - не валидность
							Else
								&apos; между ними есть текст - печатаем этот текст
								While lCurrentElement &lt; lIndexOfNextLevel
									SaveElements(sArray, sArray(lCurrentElement, 1), sArray(lCurrentElement, 0), bBody)
								Wend
							End If
							SaveCloseSection( (nCurrentLevel - nNextLevel)+1 ) &apos; закрываем &lt;/section&gt;
						End If
					End If
					If bBody Then oProgressBar.setValue(lCurrentElement) &apos; Статусбар
				Wend
			Wend
		End If
	End If
End Sub

&apos; есть ли текст между 2-мя Заголовками?
Function IsTextBetween2Levels( sArray(), nCurrentLevelIndex As Integer, nNextLevelIndex As Integer ) As Boolean
	&apos; Возвращает: False - если текста нет; True - если текст есть
	IsTextBetween2Levels = False
	Dim nIter As Integer
	For nIter = nCurrentLevelIndex To nNextLevelIndex
		If Not IsLevel( sArray( nIter,1 ) ) Then
			IsTextBetween2Levels = True : Exit Function
		End If
	Next nIter
End Function

Function SaveCloseSection(nCount As Integer) As Long
	Dim i As Integer
	If nCount &gt; 0 Then
		For i = 0 To nCount-1
			oTextOutputStream.writeString(&quot;&lt;/section&gt;&quot; &amp; chr(10))
		Next i
	End If
End Function

&apos;/////////////////
&apos; для уровней одного ранга (1,1; 3,3) ничего обрамлять секциями между этими уровнями не надо.
&apos; ТОЛЬКО Аннотация и (или) ТОЛЬКО Эпиграф - если они одни между уровнями одного ранга (поотдельности), то после них обязательно ставил пустую строку!!!
</script:module>