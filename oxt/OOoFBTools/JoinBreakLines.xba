<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE script:module PUBLIC "-//OpenOffice.org//DTD OfficeDocument 1.0//EN" "module.dtd">
<script:module xmlns:script="http://openoffice.org/2000/script" script:name="JoinBreakLines" script:language="StarBasic">REM  *****  BASIC  *****
Option Explicit

Const sConstJoinBreakLines As String = &quot;joinbreaklines.txt&quot; &apos; файл настроек

Public oJoinBreakLinesDlg			As Object

Private bBreakLinesInParaStartSpace	As Boolean
Private bBreakLinesInParaEndSymbols	As Boolean
Private bBreakLinesInFPara			As Boolean

Private bDefisWordDelOnlyPara		As Boolean
Private bDefisWordDeAll				As Boolean

Private bStartSpaceDelete			As Boolean
Private bStartNoBreakSpaceDelete	As Boolean
Private bStartTabDelete				As Boolean
Private bDelSpace					As Boolean

Sub JoinBreakLines()
&apos;	DialogLibraries.LoadLibrary(&quot;OOoFBTools&quot;)
	If Not GlobalScope.DialogLibraries.isLibraryLoaded( &quot;OOoFBTools&quot; ) Then
    	GlobalScope.DialogLibraries.LoadLibrary( &quot;OOoFBTools&quot; )
	End If
	oJoinBreakLinesDlg = CreateUnoDialog( GlobalScope.DialogLibraries.OOoFBTools.JoinBreakLinesDlg )
	
	&apos; инициализация формы диалога Склейки разорванных строк абзац
	InitJoinBreakLinesDlg()
	
	With oJoinBreakLinesDlg.Model
		.Height = 153
		.Width  = 305
	End With
	
	Dim nX As Integer, nY As Integer
	ReadDlgSettings( getOOoFBToolsSettingsDir() &amp; sConstJoinBreakLines, oJoinBreakLinesDlg, nX, nY )
	oJoinBreakLinesDlg.setPosSize( nX, nY, 153, 305, com.sun.star.awt.PosSize.POS )
	
	oJoinBreakLinesDlg.execute()

End Sub

Sub SaveJoinBreakLinesDlgSettings()
	&apos; сохранение положение формы
	SaveSettings( getOOoFBToolsSettingsDir() &amp; sConstJoinBreakLines, oJoinBreakLinesDlg )
	&apos; заполняем переменные
	With oJoinBreakLinesDlg
		bBreakLinesInParaStartSpace = .GetControl(&quot;obtBreakLinesInParaStartSpace&quot;).State
		bBreakLinesInParaEndSymbols = .GetControl(&quot;obtBreakLinesInParaEndSymbols&quot;).State
		bBreakLinesInFPara			= .GetControl(&quot;obtBreakLinesInFPara&quot;).State
	
		bDefisWordDelOnlyPara		= .GetControl(&quot;obtnDefisWordDelOnlyPara&quot;).State
		bDefisWordDeAll				= .GetControl(&quot;obtnDefisWordDeAll&quot;).State
	
		bStartSpaceDelete			= .GetControl(&quot;cboxStartSpaceDelete&quot;).State
		bStartNoBreakSpaceDelete	= .GetControl(&quot;cboxStartNoBreakSpaceDel&quot;).State
		bStartTabDelete				= .GetControl(&quot;cboxStartTabDel&quot;).State
		bDelSpace					= .GetControl(&quot;cboxDelSpace&quot;).State
	End With
End Sub

Sub JoinBreakLinesDlgOkClick()
	Dim sMessageTitle As String : sMessageTitle = sJBLD.sMessageTitle
	
	&apos; Принятие параметров чистки текста
	oJoinBreakLinesDlg.endExecute()

	&apos; сохранение настроек склейки строк
	SaveJoinBreakLinesDlgSettings()

	Dim oDoc		As Object, oReplace	As Object, oProgressBar
	Dim nCur		As Integer : nCur = 1
	oDoc = ThisComponent
	oReplace = oDoc.createReplaceDescriptor
	oReplace.SearchRegularExpression = True
	oProgressBar = oDoc.CurrentController.StatusIndicator
	
	&apos; !!!!!!!!!не переставлять местами все следующие действия ДО условия If bBreakLinesInParaStartSpace = True Then !!! Результат будет неверен!!!!!!
	&apos; Удаление мягких переносов
	With oProgressBar
		.start( sJBLD.sFrontEndProcessing &amp; &quot;:&quot;, 4 )
		.setValue(nCur)
	End With
	&apos; Заменяем разрыв строки на абзац, для обработки текста с разрывом строк &lt;BR&gt;
	With oReplace
		.SearchString = chr(10)
		.ReplaceString = &quot;\n&quot;
	End With
	oDoc.ReplaceAll(oReplace)
	nCur = nCur+1
	oProgressBar.setValue(nCur)
	&apos; Удаляем все конечные пробелы и табуляции, иначе результат будет неверным
	DelEndSpace( oDoc, oReplace )
	nCur = nCur+1
	oProgressBar.setValue(nCur)
	&apos; удаляем мягкие переносы, иначе результат будет неверным
	DeleteMPer( oDoc, oReplace )
	nCur = nCur+1
	oProgressBar.setValue(nCur)
	&apos; удаление переноса, разорванного абзацем (обработка слов с дефисами и простых слов в тексте, таблицах, сносках и врезках
	oProgressBar.start( sJBLD.sCarryingProcessing &amp; &quot;:&quot;, 100)
	JoinWordDefisParaInAllTexts( bDefisWordDelOnlyPara, bDefisWordDeAll, oProgressBar, nCur )

	&apos; ОБРАБОТКА ТЕКСТА
	oProgressBar.start( sJBLD.sJoinLines &amp; &quot;:&quot;, 100 )
	If bBreakLinesInParaStartSpace = True Then
		JoinBreakLinesInParaStartSpace( oDoc, oProgressBar )
	ElseIf bBreakLinesInParaEndSymbols = True Then
		JoinBreakLinesInParaEndSymbols( oDoc, oProgressBar )
	ElseIf bBreakLinesInFPara = True Then
		JoinBreakLinesInEmptyPara( oDoc, oProgressBar )
	End If
	
	&apos; /////////// постобработка ///////////////
	nCur = 1
	With oProgressBar
		.start( sJBLD.sPostProcessing &amp; &quot;:&quot;, 5 )
		.setValue(nCur)
	End With
	
	&apos; Удаляем все конечные пробелы и табуляции
	DelEndSpace( oDoc, oReplace )
	oProgressBar.setValue(nCur)
	nCur = nCur+1

	&apos; Удаляем все стартовые пробелы
	If bStartSpaceDelete = True Then
		DelStartSpace( oDoc, oReplace )
	End If
	oProgressBar.setValue(nCur)
	nCur = nCur+1
	
	&apos; Удаляем все стартовые неразрывные пробелы
	If bStartNoBreakSpaceDelete = True Then
		DelStartNoBreakSpace( oDoc, oReplace )
	End If
	oProgressBar.setValue(nCur)
	nCur = nCur+1
	
	&apos; Удаляем все стартовые табуляции
	If bStartTabDelete = True Then
		DelStartTab( oDoc, oReplace )
	End If
	oProgressBar.setValue(nCur)
	nCur = nCur+1
	
	&apos; Замена множественныз пробелов и табуляций на один пробел между словами
	If bDelSpace = True Then
		ReplaceMSpaceTo( oDoc, 1, True )
	End If
	oProgressBar.setValue(nCur)
	nCur = nCur+1
	MsgBox sJBLD.sEndWork, 64, sMessageTitle
	
	oProgressBar.end
End Sub

&apos;////////////////////////////////////////
&apos; сборка разорваных строк абзаца знаком абзаца в один абзац.
&apos; Идентификатор каждого &quot;нового абзаца&quot; - 1 или несколько пробелов в начале строки.
&apos; Полезно при обработке книг после сканирования и сохраненных в txt формате (таких море в сети)
Sub JoinBreakLinesInParaStartSpace( oDoc As Object, oProgressBar As Object )
	Dim vSearch As Variant, vStartFound As Variant, vEndFound As Variant
	Dim l As Long
	
	&apos; поиск абзаца-идентификатора
	vSearch = oDoc.createSearchDescriptor()
	With vSearch
		.SearchRegularExpression = True
		.SearchString = &quot;^[:space:]+&quot; &apos;&quot;^ {1,}&quot;
	End With
	&apos; Находим первый идентификатор
	vStartFound = oDoc.findFirst( vSearch )
	l = 0
	Do While Not IsNull(vStartFound)
		&apos;Поиск закрывающего разделителя, начиная с найденного открывающего
		vEndFound = oDoc.findNext( vStartFound.End, vSearch )
		If IsNull(vEndFound) Then
			&apos; Найден стартовый идентификатор без завершающего - ищем от vStartFound и до конца документа
			vEndFound = oDoc.Text.createTextCursor()
			vEndFound.GoToEnd(False)
			JoinLines( vStartFound, vEndFound, oDoc, oProgressBar, l )
			Exit Do
		Else
			vEndFound.gotoPreviousParagraph(False)
			&apos;vEndFound.gotoEndOfParagraph(False)
			JoinLines( vStartFound, vEndFound, oDoc, oProgressBar, l )
			vStartFound = oDoc.findNext( vStartFound.End, vSearch )
		End If
	Loop
End Sub

&apos; сборка разорваных строк абзаца знаком абзаца в один абзац.
&apos; Идентификатор строки &quot;одного абзаца&quot; - символы окончания предложения (.!?…»”\&quot;&quot;:;) в конце строки.
&apos; Полезно при обработке книг после сканирования и сохраненных в txt формате (таких море в сети)
Sub JoinBreakLinesInParaEndSymbols( oDoc As Object, oProgressBar As Object )
	Dim vStartSearch, vEndSearch &apos;Open и Close descriptors
	Dim vStartFound, vEndFound &apos;Open и Close find objects
	Dim l As Long
	
	&apos; Создать дескрипторы для документа, в котором возможен поиск.
	vStartSearch = oDoc.createSearchDescriptor()
	vEndSearch = oDoc.createSearchDescriptor()

	With vStartSearch
		.SearchRegularExpression = True
		&apos; Задаем текст, который нужно искать, и др.
		.SearchString = &quot;$&quot;
	End With
	With vEndSearch
		.SearchRegularExpression = True
		&apos; Задаем текст, который нужно искать, и др.
		.SearchString = &quot;[.!?…»”\&quot;&quot;:;]$&quot;
	End With

	&apos; Найти первый открывающий разделитель
	vStartFound = oDoc.findFirst(vStartSearch)
	l = 0
	Do While Not IsNull(vStartFound)
		&apos;Поиск закрывающего разделителья, начиная с найденного открывающего
		vEndFound = oDoc.findNext( vStartFound.End, vEndSearch)
		If IsNull(vEndFound) Then
			vEndFound = oDoc.Text.createTextCursor()
			vEndFound.GoToEnd(False)
			JoinLines( vStartFound, vEndFound, oDoc, oProgressBar, l )
			Exit Do
		Else
			&apos; Выделить текст внутри разделителей
			vStartFound.gotoStartOfParagraph(False)
			JoinLines( vStartFound, vEndFound, oDoc, oProgressBar, l )
			vStartFound = oDoc.findNext( vStartFound.End, vStartSearch )
		End If
	Loop
End Sub

&apos; склейка разорваных строк абзаца знаком абзаца в один абзац.
&apos; Идентификатор каждого &quot;нового абзаца&quot; - пустой абзац.
&apos; Полезно при обработке книг после сканирования и сохраненных в txt формате (таких море в сети)
Sub JoinBreakLinesInEmptyPara( oDoc As Object, oProgressBar As Object )
	Dim vStartFound As Variant, vEndFound As Variant
	Dim l As Long : l = 0

	&apos; Находим верхнюю границу области
	Dim vSearch As Variant
	vSearch = oDoc.createSearchDescriptor()
	With vSearch
		.SearchRegularExpression = True
		.SearchString = &quot;^$&quot;
	End With
	
&apos;	vStartFound = oDoc.findFirst( vSearch )
	&apos; верхняя граница - на самый верх документа
	vStartFound = oDoc.getText().createTextCursor()
	vStartFound.gotoStart( False )	
	
	&apos; поиск и обработка следующих областей, удовлетворяющих условию поиска
	Do While Not IsNull(vStartFound)
		&apos;Поиск закрывающего разделителя, начиная с найденного открывающего
		vEndFound = oDoc.findNext( vStartFound.End, vSearch )
		If IsNull(vEndFound) Then
			&apos; Найден стартовый идентификатор без завершающего - ищем от vStartFound и до конца документа
			vEndFound = oDoc.Text.createTextCursor()
			vEndFound.GoToEnd(False)
			JoinLines( vStartFound, vEndFound, oDoc, oProgressBar, l )
			Exit Do
		Else
			With vEndFound
				.gotoPreviousParagraph(False)
				.gotoPreviousParagraph(False)
			End With
			JoinLines( vStartFound, vEndFound, oDoc, oProgressBar, l )
			vStartFound = oDoc.findNext( vStartFound.End, vSearch )
		End If
	Loop
End Sub

&apos; /////////////////////////////////////////////////////////////////////////
Sub JoinLines(oLCurs, oRCurs, oDoc, oProgressBar, l)
	On Error GoTo ErrorHandler
	
	If IsNull(oLCurs) Or IsNull(oRCurs) Or IsNull(oDoc) Then Exit Sub
	If oDoc.Text.compareRegionEnds(oLCurs, oRCurs) &lt;= 0 Then Exit Sub
	oLCurs.goRight(0, False)
	Dim vDescriptor, vFound
	vDescriptor = oDoc.createSearchDescriptor()
	With vDescriptor
		.SearchString = &quot;$&quot;
		.SearchCaseSensitive = False
		.SearchRegularExpression = True
	End With
	vFound = oDoc.findNext( oLCurs, vDescriptor )
	Do While Not IsNull(vFound)
		If l&gt;=100 Then l = 0
		l = l + 1
		oProgressBar.setValue(l)
		If oDoc.Text.compareRegionEnds( vFound, oRCurs ) = -1 Then Exit Do
		vFound.setString(&quot; &quot;)
		vFound = ThisComponent.findNext( vFound.End, vDescriptor )
	Loop
ErrorHandler:
End Sub

</script:module>