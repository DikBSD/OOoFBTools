<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE script:module PUBLIC "-//OpenOffice.org//DTD OfficeDocument 1.0//EN" "module.dtd">
<script:module xmlns:script="http://openoffice.org/2000/script" script:name="JoinBreakLines" script:language="StarBasic">REM  *****  BASIC  *****
&apos; ===========================================================================================================================
&apos;													 модуль инструментов:
&apos; 												склейка разрывов строк и абзацев
&apos; ===========================================================================================================================
Option Explicit

Const sConstJoinBreakLines As String = &quot;joinbreaklines.txt&quot; &apos; файл настроек

Public oJoinBreakLinesDlg			As Object

Private bBreakLinesInParaStartSpace	As Boolean
Private bBreakLinesInParaEndSymbols	As Boolean
Private bBreakLinesInFPara			As Boolean

Private bDefisWordDelOnlyPara		As Boolean
Private bDefisWordDeAll				As Boolean

Private bStartSpaceDelete			As Boolean
Private bStartNoBreakSpaceDelete	As Boolean
Private bStartTabDelete				As Boolean
Private bDelSpace					As Boolean

Sub JoinBreakLines()
&apos;	DialogLibraries.LoadLibrary(&quot;OOoFBTools&quot;)
	If Not GlobalScope.DialogLibraries.isLibraryLoaded( &quot;OOoFBTools&quot; ) Then
    	GlobalScope.DialogLibraries.LoadLibrary( &quot;OOoFBTools&quot; )
	End If
	oJoinBreakLinesDlg = CreateUnoDialog( GlobalScope.DialogLibraries.OOoFBTools.JoinBreakLinesDlg )
	
	&apos; инициализация формы диалога Склейки разорванных строк абзац
	InitJoinBreakLinesDlg()
	
	With oJoinBreakLinesDlg.Model
		.Height = 153
		.Width  = 305
	End With
	
	Dim nX As Integer, nY As Integer
	ReadDlgSettings( getOOoFBToolsSettingsDir() &amp; sConstJoinBreakLines, oJoinBreakLinesDlg, nX, nY )
	oJoinBreakLinesDlg.setPosSize( nX, nY, 153, 305, com.sun.star.awt.PosSize.POS )
	
	oJoinBreakLinesDlg.execute()

End Sub

&apos; сохранение положение формы
Sub SaveJoinBreakLinesDlgSettings()
	SaveSettings( getOOoFBToolsSettingsDir() &amp; sConstJoinBreakLines, oJoinBreakLinesDlg )
	&apos; заполняем переменные
	With oJoinBreakLinesDlg
		bBreakLinesInParaStartSpace = .GetControl(&quot;obtBreakLinesInParaStartSpace&quot;).State
		bBreakLinesInParaEndSymbols = .GetControl(&quot;obtBreakLinesInParaEndSymbols&quot;).State
		bBreakLinesInFPara			= .GetControl(&quot;obtBreakLinesInFPara&quot;).State
	
		bDefisWordDelOnlyPara		= .GetControl(&quot;obtnDefisWordDelOnlyPara&quot;).State
		bDefisWordDeAll				= .GetControl(&quot;obtnDefisWordDeAll&quot;).State
	
		bStartSpaceDelete			= .GetControl(&quot;cboxStartSpaceDelete&quot;).State
		bStartNoBreakSpaceDelete	= .GetControl(&quot;cboxStartNoBreakSpaceDel&quot;).State
		bStartTabDelete				= .GetControl(&quot;cboxStartTabDel&quot;).State
		bDelSpace					= .GetControl(&quot;cboxDelSpace&quot;).State
	End With
End Sub

Sub JoinBreakLinesDlgOkClick()
	Dim sMessageTitle As String : sMessageTitle = sJBLD.sMessageTitle
	
	&apos; Принятие параметров чистки текста
	oJoinBreakLinesDlg.endExecute()

	&apos; сохранение настроек склейки строк
	SaveJoinBreakLinesDlgSettings()

	Dim oDoc		As Object, oReplace	As Object, oProgressBar
	Dim nCur		As Integer : nCur = 1
	oDoc = ThisComponent
	oReplace = oDoc.createReplaceDescriptor
	oReplace.SearchRegularExpression = True
	oProgressBar = oDoc.CurrentController.StatusIndicator
	
	&apos; !!!!!!!!!не переставлять местами все следующие действия ДО условия If bBreakLinesInParaStartSpace = True Then !!! Результат будет неверен!!!!!!
	&apos; Удаление мягких переносов
	With oProgressBar
		.start( sJBLD.sFrontEndProcessing &amp; &quot;:&quot;, 4 )
		.setValue(nCur)
	End With
	&apos; Заменяем разрыв строки на абзац, для обработки текста с разрывом строк &lt;BR&gt;
	With oReplace
		.SearchString = chr(10)
		.ReplaceString = &quot;\n&quot;
	End With
	oDoc.ReplaceAll(oReplace)
	nCur = nCur+1
	oProgressBar.setValue(nCur)
	&apos; Удаляем все конечные пробелы и табуляции, иначе результат будет неверным
	DelEndSpace( oDoc, oReplace )
	nCur = nCur+1
	oProgressBar.setValue(nCur)
	&apos; удаляем мягкие переносы, иначе результат будет неверным
	DeleteMPer( oDoc, oReplace )
	nCur = nCur+1
	oProgressBar.setValue(nCur)
	&apos; удаление переноса, разорванного абзацем (обработка слов с дефисами и простых слов в тексте, таблицах, сносках и врезках
	oProgressBar.start( sJBLD.sCarryingProcessing &amp; &quot;:&quot;, 100)
	JoinWordDefisParaInAllTexts( bDefisWordDelOnlyPara, bDefisWordDeAll, oProgressBar, nCur )

	&apos; ОБРАБОТКА ТЕКСТА
	oProgressBar.start( sJBLD.sJoinLines &amp; &quot;:&quot;, 100 )
	If bBreakLinesInParaStartSpace = True Then
		JoinBreakLinesInParaStartSpace( oDoc, oProgressBar )
	ElseIf bBreakLinesInParaEndSymbols = True Then
		JoinBreakLinesInParaEndSymbols( oDoc, oProgressBar )
	ElseIf bBreakLinesInFPara = True Then
		JoinBreakLinesInEmptyPara( oDoc, oProgressBar )
	End If
	
	&apos; ============ постобработка =================
	nCur = 1
	With oProgressBar
		.start( sJBLD.sPostProcessing &amp; &quot;:&quot;, 5 )
		.setValue(nCur)
	End With
	
	&apos; Удаляем все конечные пробелы и табуляции
	DelEndSpace( oDoc, oReplace )
	oProgressBar.setValue(nCur)
	nCur = nCur+1

	&apos; Удаляем все стартовые пробелы
	If bStartSpaceDelete = True Then
		DelStartSpace( oDoc, oReplace )
	End If
	oProgressBar.setValue(nCur)
	nCur = nCur+1
	
	&apos; Удаляем все стартовые неразрывные пробелы
	If bStartNoBreakSpaceDelete = True Then
		DelStartNoBreakSpace( oDoc, oReplace )
	End If
	oProgressBar.setValue(nCur)
	nCur = nCur+1
	
	&apos; Удаляем все стартовые табуляции
	If bStartTabDelete = True Then
		DelStartTab( oDoc, oReplace )
	End If
	oProgressBar.setValue(nCur)
	nCur = nCur+1
	
	&apos; Замена множественныз пробелов и табуляций на один пробел между словами
	If bDelSpace = True Then
		ReplaceMSpaceTo( oDoc, 1, True )
	End If
	oProgressBar.setValue(nCur)
	nCur = nCur+1
	MsgBox sJBLD.sEndWork, 64, sMessageTitle
	
	oProgressBar.End
End Sub

&apos; =================================================================================================
&apos; 								Алгоритмы склейки абзацев
&apos; =================================================================================================
&apos; сборка разорваных строк абзаца знаком абзаца в один абзац.
&apos; Идентификатор каждого &quot;нового абзаца&quot; - 1 или несколько пробелов в начале строки.
&apos; Полезно при обработке книг после сканирования и сохраненных в txt формате (таких сножество в сети)
Sub JoinBreakLinesInParaStartSpace( oDoc As Object, oProgressBar As Object )
	Dim vSearch As Variant, vStartFound As Variant, vEndFound As Variant
	Dim l As Long : l = 0
	
	&apos; поиск абзаца-идентификатора
	vSearch = oDoc.createSearchDescriptor()
	With vSearch
		.SearchRegularExpression = True
		.SearchString = &quot;^[:space:]+&quot; &apos;&quot;^ {1,}&quot;
	End With
	
	&apos; Находим первый идентификатор
	vStartFound = oDoc.FindFirst( vSearch )
	If Not IsNull( vStartFound ) Then 
		Do
			&apos;Поиск закрывающего разделителя, начиная с найденного открывающего
			vEndFound = oDoc.findNext( vStartFound.End, vSearch )
			If Not IsNull( vEndFound ) Then
				&apos; нашли следующий стартовый идентификатор
				vEndFound.gotoPreviousParagraph( False )
				&apos;vEndFound.gotoEndOfParagraph( False )
				JoinLines( vStartFound, vEndFound, oDoc, oProgressBar, l )
				vStartFound = oDoc.findNext( vStartFound.End, vSearch )
			Else
				&apos; Найден стартовый идентификатор без завершающего: склеиваем абзацы от vStartFound и до конца документа
				vEndFound = oDoc.Text.createTextCursor()
				vEndFound.GoToEnd( False )
				JoinLines( vStartFound, vEndFound, oDoc, oProgressBar, l )
				Exit Do
			End If
		Loop Until IsNull( vStartFound ) &apos; выполняем хотя бы раз пока vStartFound не пусто
	End If
End Sub

&apos; сборка разорваных строк абзаца знаком абзаца в один абзац.
&apos; Идентификатор строки &quot;одного абзаца&quot; - символы окончания предложения (.!?…»”\&quot;&quot;:;) в конце строки.
&apos; Полезно при обработке книг после сканирования и сохраненных в txt формате (таких множество в сети)
Sub JoinBreakLinesInParaEndSymbols( oDoc As Object, oProgressBar As Object )
	&apos; Создаем поисковые дескрипторы для документа
	Dim vStartSearch	As Variant : vStartSearch	= oDoc.createSearchDescriptor()
	Dim vEndSearch		As Variant : vEndSearch		= oDoc.createSearchDescriptor()

	With vStartSearch
		.SearchRegularExpression = True
		.SearchString = &quot;$&quot; &apos; поисковый аргумент начала абзаца для склейки
	End With
	With vEndSearch
		.SearchRegularExpression = True
		.SearchString = &quot;[.!?…»”\&quot;&quot;:;]$&quot; &apos; поисковый аргумент конца абзаца для склейки
	End With

	&apos; Найти первый открывающий разделитель
	Dim vStartFound	As Variant : vStartFound = oDoc.findFirst( vStartSearch )
	Dim vEndFound	As Variant
	Dim l As Long : l = 0
	Do While Not IsNull( vStartFound )
		&apos;Поиск закрывающего разделителья, начиная с найденного открывающего
		vEndFound = oDoc.findNext( vStartFound.End, vEndSearch)
		If Not IsNull(vEndFound) Then
			&apos; Выделить текст внутри разделителей
			vStartFound.gotoStartOfParagraph(False)
			JoinLines( vStartFound, vEndFound, oDoc, oProgressBar, l )
			vStartFound = oDoc.findNext( vStartFound.End, vStartSearch )
		Else
			&apos; Найден стартовый идентификатор без завершающего: склеиваем абзацы от vStartFound и до конца документа
			vEndFound = oDoc.Text.createTextCursor()
			vEndFound.GoToEnd(False)
			JoinLines( vStartFound, vEndFound, oDoc, oProgressBar, l )
			Exit Do
		End If
	Loop
End Sub

&apos; склейка разорваных строк абзаца знаком абзаца в один абзац.
&apos; Идентификатор каждого &quot;нового абзаца&quot; - пустой абзац.
&apos; Полезно при обработке книг после сканирования и сохраненных в txt формате (таких множество в сети)
Sub JoinBreakLinesInEmptyPara( oDoc As Object, oProgressBar As Object )
	&apos; Находим верхнюю границу области
	Dim vSearch As Variant : vSearch = oDoc.createSearchDescriptor()
	With vSearch
		.SearchRegularExpression = True
		.SearchString = &quot;^$&quot;
	End With
	
	&apos; верхняя граница - на самый верх документа
	Dim vStartFound As Variant : vStartFound = oDoc.getText().createTextCursor()
&apos;	vStartFound = oDoc.findFirst( vSearch )
	vStartFound.gotoStart( False )	
	Dim vEndFound As Variant
	&apos; поиск и обработка следующих областей, удовлетворяющих условию поиска
	Dim l As Long : l = 0
	Do While Not IsNull( vStartFound )
		&apos;Поиск закрывающего разделителя, начиная с найденного открывающего
		vEndFound = oDoc.findNext( vStartFound.End, vSearch )
		If Not IsNull( vEndFound ) Then
			With vEndFound
				.gotoPreviousParagraph(False)
				.gotoPreviousParagraph(False)
			End With
			JoinLines( vStartFound, vEndFound, oDoc, oProgressBar, l )
			vStartFound = oDoc.findNext( vStartFound.End, vSearch )
		Else
			&apos; Найден стартовый идентификатор без завершающего: склеиваем абзацы от vStartFound и до конца документа
			vEndFound = oDoc.Text.createTextCursor()
			vEndFound.GoToEnd(False)
			JoinLines( vStartFound, vEndFound, oDoc, oProgressBar, l )
			Exit Do
		End If
	Loop
End Sub

&apos; ==========================================================================================
&apos; 								склейка строк и/или абзацев
&apos; ==========================================================================================
Sub JoinLines( oLCurs, oRCurs, oDoc, oProgressBar, l )
	If IsNull( oLCurs ) Or IsNull( oRCurs ) Or IsNull( oDoc ) Then Exit Sub
	Dim oCursorL As Object : oCursorL = oLCurs.getText().createTextCursorByRange( oLCurs )
	Dim oCursorR As Object : oCursorR = oRCurs.getText().createTextCursorByRange( oRCurs )
&apos;	If oCursorL.Text.compareRegionEnds( oCursorL, oCursorR ) &lt;= 0 Then Exit Sub

	Dim vSearch As Variant : vSearch = oDoc.createSearchDescriptor()
	With vSearch
		.SearchString = &quot;$&quot;
		.SearchCaseSensitive = False
		.SearchRegularExpression = True
	End With
	
	Dim vFound  As Object : vFound = oDoc.findNext( oCursorL, vSearch )
	Do While Not IsNull( vFound )
		If l&gt;=100 Then l = 0
		l = l + 1
		oProgressBar.setValue(l)
		On Local Error Resume Next &apos; TODO код следующей строки то срабатывает, не выдает ошибку. если выделены сноски и текст в документе.
		If vFound.Text.compareRegionEnds( vFound, oCursorR ) = -1 Then Exit Do
		vFound.setString(&quot; &quot;)
		vFound = oDoc.findNext( vFound.End, vSearch )
	Loop
End Sub

</script:module>