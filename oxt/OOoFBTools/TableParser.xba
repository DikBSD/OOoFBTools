<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE script:module PUBLIC "-//OpenOffice.org//DTD OfficeDocument 1.0//EN" "module.dtd">
<script:module xmlns:script="http://openoffice.org/2000/script" script:name="TableParser" script:language="StarBasic">REM  *****  BASIC  *****
Option Explicit
&apos; /// Парсер таблиц ///
Function MakeFB2ParasRow( aFB2ParasRow() As String, aCellAllFormatText() As Variant, nMaxLines As Integer, sAlling As String ) As Variant
	&apos; формируем промежуточный массив массивов строк таблицы с &quot;виртуальными&quot; абзацами из &quot;виртуальных&quot; ячеек
	Dim i As Integer &apos; размерность массива
	&apos; формируем fb2 код Ячейки со всеми абзацами
	Dim aCellWithLines(nMaxLines) As String
	aCellWithLines = MakeFB2ParasCell( aCellAllFormatText(), nMaxLines )
	&apos; формируем промежуточный массив массивов строк таблицы с &quot;виртуальными&quot; абзацами из &quot;виртуальных&quot; ячеек
	i = Ubound(aFB2ParasRow(), 1) + 1
	If i &gt; 0 Then
		ReDim Preserve aFB2ParasRow(i, nMaxLines+1)
	Else Redim aFB2ParasRow(i, nMaxLines+1)
	End If
	Dim j As Integer
	For j = 0 To nMaxLines
		aFB2ParasRow(UBound(aFB2ParasRow), j) = aCellWithLines(j)
	Next j
	aFB2ParasRow(UBound(aFB2ParasRow), (nMaxLines+1)) = sAlling &apos; выравнивание ячейки
	MakeFB2ParasRow = aFB2ParasRow &apos; Сформированный fb2 код всей Строки со всеми абзацами
End Function

Function MakeFB2ParasCell( aCellAllFormatText() As Variant, nMaxLines As Integer) As Variant
	&apos; формируем fb2 код Ячейки со всеми абзацами
	Dim i As Integer, j As Integer
	Dim aCellWithLines(nMaxLines) As String &apos; Сформированный fb2 код Ячейки со всеми абзацами
	For i = LBound(aCellAllFormatText) To nMaxLines
		&apos; Выравнивание строк: влево - 0, вправо - 1, по центру - 3, по ширине - 2	
		If UBound(aCellAllFormatText) = nMaxLines Then		
			aCellWithLines(i) = aCellAllFormatText(i) &amp; chr(10)
		Else &apos; дополняем &quot;отсутствующие&quot; строки до числа nMaxLines
			For j = 0 To UBound(aCellAllFormatText)
				aCellWithLines(j) = aCellAllFormatText(j) &amp; chr(10)
			Next j
			For j = UBound(aCellAllFormatText)+1 To nMaxLines
				aCellWithLines(j) = &quot;&quot; &amp; chr(10)
			Next j
			Exit For
		End If
	Next i
	MakeFB2ParasCell = aCellWithLines
End Function

Function MakeRowForFullRow( aRow As String, nHeaderRowCount As Integer, nRow As String ) As String
	&apos; формирование строки &lt;tr&gt; для “полной” строк
	Dim sTRTag As String, sTagTDH As String, sRow As String, i As Integer
	For i = 0 To UBound(aRow())
		sTRTag = MakeTRTag(sLineTRA)
		sTagTDH = MakeValignAttrComplex(aRow(i,1)), sLineTVA, &quot;td&quot;)
		&apos; обработка заголовков таблицы
		If nHeaderRowCount &gt; 0 Then
			If	nRow &lt;= nHeaderRowCount Then &apos; для заголовков сложной таблицы
				sTRTag = MakeTRTag(sHeaderTRA)
				sTagTDH = MakeValignAttrComplex(aRow(i,1), sHeaderTVA, &quot;th&quot;)
				sRow = sRow &amp; sTagTDH &amp; &quot;&quot;&quot;&gt;&quot; &amp; aRow(i,0) &amp; &quot;&lt;/th&gt;&quot; &amp; chr(10)
			Else
				sRow = sRow &amp; sTagTDH &amp; &quot;&quot;&quot;&gt;&quot; &amp; aRow(i,0) &amp; &quot;&lt;/td&gt;&quot; &amp; chr(10)
			End If
		Else
			sRow = sRow &amp; sTagTDH &amp; &quot;&quot;&quot;&gt;&quot; &amp; aRow(i,0) &amp; &quot;&lt;/td&gt;&quot; &amp; chr(10)
		End If
	Next i
	MakeRowForFullRow = sRow
End Function

Function MakeRowForCutRow( aRow As String, nHeaderRowCount As Integer, nRow As String ) As String
	&apos; формирование строки &lt;tr&gt; для “урезанной” строки
	&apos; Теперь – алгоритм определения самой “длинной” ячейки по ее width.
	&apos; для нее colspan = nCollMaxInTable+1 - UBound(aRow())
	&apos; формирование строки &lt;tr&gt; для ячейки с colspan для “длинной” ячейки
	Dim sTRTag As String, sTagTDH As String, sRow As String, i As Integer
	For i = 0 To UBound(aRow())
		sTRTag = MakeTRTag(sLineTRA)
		sTagTDH = MakeValignAttrComplex(aRow(i,1), sLineTVA, &quot;td&quot;)
		&apos; обработка заголовков таблицы
		If nHeaderRowCount &gt; 0 Then
			If	nRow &lt;= nHeaderRowCount Then &apos; для заголовков сложной таблицы
				sTRTag = MakeTRTag(sHeaderTRA)
				sTagTDH = MakeValignAttrComplex(aRow(i,1), sHeaderTVA, &quot;th&quot;)
				sRow = sRow &amp; sTagTDH &amp; &quot;&quot;&quot;&gt;&quot; &amp; aRow(i,0) &amp; &quot;&lt;/th&gt;&quot; &amp; chr(10)
			Else
				sRow = sRow &amp; sTagTDH &amp; &quot;&quot;&quot;&gt;&quot; &amp; aRow(i,0) &amp; &quot;&lt;/td&gt;&quot; &amp; chr(10)
			End If
		Else
			sRow = sRow &amp; sTagTDH &amp; &quot;&quot;&quot;&gt;&quot; &amp; aRow(i,0) &amp; &quot;&lt;/td&gt;&quot; &amp; chr(10)
		End If
	Next i
	MakeRowForCutRow = sRow
End Function

Function MakeRowForOneRow( aRow As String, nHeaderRowCount As Integer, nRow As String, nCollMaxInTable As Integer ) As String
	&apos; формирование строки &lt;tr&gt; для строки из 1-й ячейки (colspan=nCollMaxInTable)
	Dim sTRTag As String, sTagTDH As String, sRow As String
	sTRTag = MakeTRTag(sLineTRA)
	sTagTDH = MakeValignAttrComplex(aRow(0,1), sLineTVA, &quot;td&quot;)
	&apos; обработка заголовков таблицы
	If nHeaderRowCount &gt; 0 Then
		If	nRow &lt;= nHeaderRowCount Then &apos; для заголовков сложной таблицы
			sTRTag = MakeTRTag(sHeaderTRA)
			sTagTDH = MakeValignAttrComplex(aRow(0,1), sHeaderTVA, &quot;th&quot;)
			sRow = sRow &amp; sTagTDH &amp; &quot;&quot;&quot; colspan=&quot;&quot;&quot; &amp; nCollMaxInTable &amp; &quot;&quot;&quot;&gt;&quot; &amp; aRow(0,0) &amp; &quot;&lt;/th&gt;&quot; &amp; chr(10)
		Else
			sRow = sRow &amp; sTagTDH &amp; &quot;&quot;&quot; colspan=&quot;&quot;&quot; &amp; nCollMaxInTable &amp; &quot;&quot;&quot;&gt;&quot; &amp; aRow(0,0) &amp; &quot;&lt;/td&gt;&quot; &amp; chr(10)
		End If
	Else
		sRow = sRow &amp; sTagTDH &amp; &quot;&quot;&quot; colspan=&quot;&quot;&quot; &amp; nCollMaxInTable &amp; &quot;&quot;&quot;&gt;&quot; &amp; aRow(0,0) &amp; &quot;&lt;/td&gt;&quot; &amp; chr(10)
	End If
	MakeRowForOneRow = sRow
End Function

Function MakeTRRow( aRow() As String, nHeaderRowCount As Integer, nRow As Integer, nCollMaxInTable As Integer ) As String
	&apos; создание &lt;tr&gt; строки для сложной таблицы
	Dim sRow As String
	&apos; определяем тип строки:
	If UBound(aRow()) = nCollMaxInTable-1 Then
		&apos; формирование строки &lt;tr&gt; для “полной” строки
		sRow = sRow &amp; MakeRowForFullRow( aRow, nHeaderRowCount, nRow )
	Else &apos; число ячеек строки &lt; число столбцов самой “длинной” строки таблицы
		If UBound(aRow()) &gt; 0 Then &apos; “урезанная” строка.
			&apos; формирование строки &lt;tr&gt; для “урезанных” строк
			sRow = sRow &amp; MakeRowForCutRow( aRow, nHeaderRowCount, nRow )
		Else &apos; строка из одной строки
			&apos; формирование строки &lt;tr&gt; для sRow строки, состоящей из 1-й ячейки (colspan=nCollMaxInTable)
			sRow = sRow &amp; MakeRowForOneRow( aRow, nHeaderRowCount, nRow, nCollMaxInTable )
		End If
	End If
	MakeTRRow = sRow
End Function

Function MakeValignAttrComplex(sTA As String, sTVA As String, sTHDTag As String) As String
	&apos; для сложных таблиц: обработка атрибутов valign - если они &quot;пустые&quot; - то их не заносим в fb2 код
	&apos; sTHDTag - тэг th или td
	Dim sTagTDHAttr As String
	sTagTDHAttr = &quot;&lt;&quot; &amp; sTHDTag &amp; &quot; align=&quot;&quot;&quot; &amp; sTA
	If sTVA &lt;&gt; &quot;&quot; Then
		sTagTDHAttr = sTagTDHAttr &amp; &quot;&quot;&quot; valign=&quot;&quot;&quot; &amp; sTVA
	End If
	MakeValignAttrComplex = sTagTDHAttr
End Function


</script:module>