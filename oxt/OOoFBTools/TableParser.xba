<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE script:module PUBLIC "-//OpenOffice.org//DTD OfficeDocument 1.0//EN" "module.dtd">
<script:module xmlns:script="http://openoffice.org/2000/script" script:name="TableParser" script:language="StarBasic">REM  *****  BASIC  *****
Option Explicit
&apos; /// Парсер таблиц ///
Function MakeFB2ParasRow( aFB2ParasRow() As String, aCellAllFormatText() As Variant, _
							nMaxLines As Integer, sAlling As String, _
							nHeaderRowCount As Integer, nRow As String ) As Variant
	&apos; формируем промежуточный массив массивов строк таблицы с &quot;виртуальными&quot; абзацами из &quot;виртуальных&quot; ячеек
	Dim i As Integer &apos; размерность массива
	&apos; 1. формируем fb2 код Ячейки со всеми абзацами
	Dim aCellWithLines(nMaxLines) As String
	aCellWithLines = MakeFB2ParasCell( aCellAllFormatText(), nMaxLines )
	
	&apos; 2. задаем аттрибуты
	Dim sTRTag As String, sTagTDH As String, sTagStart As String, sTagEnd As String
	sTRTag = MakeTRTag(sLineTRA)
	sTagTDH = MakeValignAttrComplex(sAlling), sLineTVA, &quot;td&quot;)
	&apos; обработка заголовков таблицы
	If nHeaderRowCount &gt; 0 Then
		If	nRow &lt; nHeaderRowCount Then &apos; для заголовков сложной таблицы
			sTRTag = MakeTRTag(sHeaderTRA)
			sTagTDH = MakeValignAttrComplex(sAlling, sHeaderTVA, &quot;th&quot;)
			sTagStart = sTagStart &amp; sTagTDH &amp; &quot;&gt;&quot;
			sTagEnd = &quot;&lt;/th&gt;&quot;
		Else
			sTagStart = sTagStart &amp; sTagTDH &amp; &quot;&gt;&quot;
			sTagEnd = &quot;&lt;/td&gt;&quot;
		End If
	Else
		sTagStart = sTagStart &amp; sTagTDH &amp; &quot;&gt;&quot;
		sTagEnd = &quot;&lt;/td&gt;&quot;
	End If
	
	&apos; 3. формируем промежуточный массив массивов строк таблицы с &quot;виртуальными&quot; абзацами из &quot;виртуальных&quot; ячеек
	i = Ubound(aFB2ParasRow(), 1) + 1
	If i &gt; 0 Then
		ReDim Preserve aFB2ParasRow(i, nMaxLines)
	Else Redim aFB2ParasRow(i, nMaxLines)
	End If
	Dim j As Integer
	For j = 0 To nMaxLines
		aFB2ParasRow(UBound(aFB2ParasRow), j) = sTagStart &amp; aCellWithLines(j) &amp; sTagEnd
	Next j

	MakeFB2ParasRow = aFB2ParasRow &apos; Сформированный fb2 код всей Строки со всеми абзацами
End Function

Function MakeFB2ParasCell( aCellAllFormatText() As Variant, nMaxLines As Integer) As Variant
	&apos; формируем fb2 код Ячейки со всеми абзацами
	Dim i As Integer, j As Integer
	Dim aCellWithLines(nMaxLines) As String &apos; Сформированный fb2 код Ячейки со всеми абзацами
	For i = LBound(aCellAllFormatText) To nMaxLines
		&apos; Выравнивание строк: влево - 0, вправо - 1, по центру - 3, по ширине - 2	
		If UBound(aCellAllFormatText) = nMaxLines Then		
			aCellWithLines(i) = aCellAllFormatText(i) &amp; chr(10)
		Else &apos; дополняем &quot;отсутствующие&quot; строки до числа nMaxLines
			For j = 0 To UBound(aCellAllFormatText)
				aCellWithLines(j) = aCellAllFormatText(j) &amp; chr(10)
			Next j
			For j = UBound(aCellAllFormatText)+1 To nMaxLines
				aCellWithLines(j) = &quot;&quot; &amp; chr(10)
			Next j
			Exit For
		End If
	Next i
	MakeFB2ParasCell = aCellWithLines
End Function

Function MakeRowForFullRow( aFB2ParasRow() As String, aRow() As String, nHeaderRowCount As Integer, nRow As String ) As String
	&apos; формирование строки &lt;tr&gt; для “полной” строки
	Dim sTRTag As String, sTagTDH As String, sRow As String, i As Integer
	For i = 0 To UBound(aRow())
		sTRTag = MakeTRTag(sLineTRA)
		sTagTDH = MakeValignAttrComplex(aRow(i,1)), sLineTVA, &quot;td&quot;)
		&apos; обработка заголовков таблицы
		If nHeaderRowCount &gt; 0 Then
			If	nRow &lt;= nHeaderRowCount Then &apos; для заголовков сложной таблицы
				sTRTag = MakeTRTag(sHeaderTRA)
				sTagTDH = MakeValignAttrComplex(aRow(i,1), sHeaderTVA, &quot;th&quot;)
				sRow = sRow &amp; sTagTDH &amp; &quot;&gt;&quot; &amp; aRow(i,0) &amp; &quot;&lt;/th&gt;&quot; &amp; chr(10)
			Else
				sRow = sRow &amp; sTagTDH &amp; &quot;&gt;&quot; &amp; aRow(i,0) &amp; &quot;&lt;/td&gt;&quot; &amp; chr(10)
			End If
		Else
			sRow = sRow &amp; sTagTDH &amp; &quot;&gt;&quot; &amp; aRow(i,0) &amp; &quot;&lt;/td&gt;&quot; &amp; chr(10)
		End If
	Next i
	MakeRowForFullRow = sRow
End Function

Function MakeRowForCutRow( aFB2ParasRow() As String, aRow() As String, nHeaderRowCount As Integer, nRow As String ) As String
	&apos; формирование строки &lt;tr&gt; для “урезанной” строки
	&apos; Теперь – алгоритм определения самой “длинной” ячейки по ее width.
	&apos; для нее colspan = nCollMaxInTable+1 - UBound(aRow())
	&apos; формирование строки &lt;tr&gt; для ячейки с colspan для “длинной” ячейки
	Dim sTRTag As String, sTagTDH As String, sRow As String, i As Integer
	For i = 0 To UBound(aRow())
		sTRTag = MakeTRTag(sLineTRA)
		sTagTDH = MakeValignAttrComplex(aRow(i,1), sLineTVA, &quot;td&quot;)
		&apos; обработка заголовков таблицы
		If nHeaderRowCount &gt; 0 Then
			If	nRow &lt;= nHeaderRowCount Then &apos; для заголовков сложной таблицы
				sTRTag = MakeTRTag(sHeaderTRA)
				sTagTDH = MakeValignAttrComplex(aRow(i,1), sHeaderTVA, &quot;th&quot;)
				sRow = sRow &amp; sTagTDH &amp; &quot;&gt;&quot; &amp; aRow(i,0) &amp; &quot;&lt;/th&gt;&quot; &amp; chr(10)
			Else
				sRow = sRow &amp; sTagTDH &amp; &quot;&gt;&quot; &amp; aRow(i,0) &amp; &quot;&lt;/td&gt;&quot; &amp; chr(10)
			End If
		Else
			sRow = sRow &amp; sTagTDH &amp; &quot;&gt;&quot; &amp; aRow(i,0) &amp; &quot;&lt;/td&gt;&quot; &amp; chr(10)
		End If
		&apos; вставляем colspan для “урезанной” строки
		InsertColspanForCutRow( aFB2ParasRow() )
	Next i
	MakeRowForCutRow = sRow
End Function

Function MakeRowForOneRow( aFB2ParasRow() As String, aRow() As String, nHeaderRowCount As Integer, nRow As String, nCollMaxInTable As Integer ) As String
	&apos; формирование строки &lt;tr&gt; для строки из 1-й ячейки (colspan=nCollMaxInTable)
	Dim sTRTag As String, sTagTDH As String, sRow As String
	Dim sStr As String
	sTRTag = MakeTRTag(sLineTRA)
	sTagTDH = MakeValignAttrComplex(aRow(0,1), sLineTVA, &quot;td&quot;)
	&apos; обработка заголовков таблицы
	If nHeaderRowCount &gt; 0 Then
		If	nRow &lt;= nHeaderRowCount Then &apos; для заголовков сложной таблицы
			sTRTag = MakeTRTag(sHeaderTRA)
			sTagTDH = MakeValignAttrComplex(aRow(0,1), sHeaderTVA, &quot;th&quot;)
			sRow = sRow &amp; sTagTDH &amp; &quot; colspan=&quot;&quot;&quot; &amp; nCollMaxInTable &amp; &quot;&quot;&quot;&gt;&quot; &amp; aRow(0,0) &amp; &quot;&lt;/th&gt;&quot; &amp; chr(10)
		Else
			sRow = sRow &amp; sTagTDH &amp; &quot; colspan=&quot;&quot;&quot; &amp; nCollMaxInTable &amp; &quot;&quot;&quot;&gt;&quot; &amp; aRow(0,0) &amp; &quot;&lt;/td&gt;&quot; &amp; chr(10)
		End If
	Else
		sRow = sRow &amp; sTagTDH &amp; &quot; colspan=&quot;&quot;&quot; &amp; nCollMaxInTable &amp; &quot;&quot;&quot;&gt;&quot; &amp; aRow(0,0) &amp; &quot;&lt;/td&gt;&quot; &amp; chr(10)
	End If
	&apos; вставляем colspan
	InsertColspanFor1Row( aFB2ParasRow(), nCollMaxInTable )
	MakeRowForOneRow = sRow
End Function

Function MakeTRRow( aFB2ParasRow() As String, aRow() As String, nHeaderRowCount As Integer, nRow As Integer, _
					nCollMaxInTable As Integer, nMaxLines As Integer ) As String
	&apos; создание &lt;tr&gt; строки для сложной таблицы
	Dim sRow As String
	&apos; определяем тип строки:
	If UBound(aRow()) = nCollMaxInTable-1 Then
		&apos; формирование строки &lt;tr&gt; для “полной” строки
		sRow = sRow &amp; MakeRowForFullRow( aFB2ParasRow(), aRow(), nHeaderRowCount, nRow )
	Else &apos; число ячеек строки &lt; число столбцов самой “длинной” строки таблицы
		If UBound(aRow()) &gt; 0 Then &apos; “урезанная” строка.
			&apos; формирование строки &lt;tr&gt; для “урезанных” строк
			sRow = sRow &amp; MakeRowForCutRow( aFB2ParasRow(), aRow(), nHeaderRowCount, nRow )
		Else &apos; строка из одной строки
			&apos; формирование строки &lt;tr&gt; для sRow строки, состоящей из 1-й ячейки (colspan=nCollMaxInTable)
			sRow = sRow &amp; MakeRowForOneRow( aFB2ParasRow(), aRow(), nHeaderRowCount, nRow, nCollMaxInTable )
		End If
	End If
	
	&apos; объединяем строки одной линии из смежных ячеек
	Dim aMergeVirtPara(nMaxLines) As String, i As Integer, j As Integer
	For i = 0 To UBound(aFB2ParasRow)
		If nMaxLines &gt; 0 Then
			For j = 0 To nMaxLines
				aMergeVirtPara(j) = aMergeVirtPara(j) &amp; aFB2ParasRow(i, j)
			Next j
		Else
			aMergeVirtPara(0) = aMergeVirtPara(0) &amp; aFB2ParasRow(i, 0)
		End If
	Next i
	
	&apos; формирует строку таблицы
	sRow = &quot;&quot;
	For i = 0 To UBound(aMergeVirtPara())
		sRow = sRow &amp; &quot;&lt;tr&gt;&quot; &amp; chr(10) &amp; aMergeVirtPara(i) &amp; &quot;&lt;/tr&gt;&quot; &amp; chr(10)
	Next i
	
	MakeTRRow = sRow
End Function

Function MakeValignAttrComplex(sTA As String, sTVA As String, sTHDTag As String) As String
	&apos; для сложных таблиц: обработка атрибутов valign - если они &quot;пустые&quot; - то их не заносим в fb2 код
	&apos; sTHDTag - тэг th или td
	Dim sTagTDHAttr As String
	sTagTDHAttr = &quot;&lt;&quot; &amp; sTHDTag &amp; &quot; align=&quot;&quot;&quot; &amp; sTA &amp; &quot;&quot;&quot;&quot;
	If sTVA &lt;&gt; &quot;&quot; Then
		sTagTDHAttr = sTagTDHAttr &amp; &quot; valign=&quot;&quot;&quot; &amp; sTVA &amp; &quot;&quot;&quot;&quot;
	End If
	MakeValignAttrComplex = sTagTDHAttr
End Function

Function InsertColspanFor1Row( aFB2ParasRow() As String, nCollMaxInTable As Integer )
	&apos; вставляем colspan для строки из 1-й ячейки (colspan=nCollMaxInTable)
	Dim sStr As String
	sStr = aFB2ParasRow(0,0)
	InsertInString( sStr, &quot;&gt;&quot;, &quot; colspan=&quot;&quot;&quot; &amp; nCollMaxInTable &amp; &quot;&quot;&quot;&gt;&quot; )
	aFB2ParasRow(0,0) = sStr
End Function

Function InsertColspanForCutRow( aFB2ParasRow() As String )
	&apos; вставляем colspan для “урезанной” строки
&apos;	Dim sStr As String, l As Long
&apos;	For l=0 To UBound(aFB2ParasRow())
&apos;		sStr = aFB2ParasRow(0,0)
&apos;		InsertInString( sStr, &quot;&gt;&quot;, &quot; colspan=&quot;&quot;&quot; &amp; ??? &amp; &quot;&quot;&quot;&gt;&quot; )
&apos;		aFB2ParasRow(0,0) = sStr
&apos;	Next l
End Function

</script:module>